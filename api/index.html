{"posts":[{"content":" 每天你都有机会跟别人擦身而过，你也许对他一无所知，不过也许有一天，他会变成一个朋友或者是知己。 by《重庆森林》 ","tags":[{"name":"Think","slug":"TG-Vv40Nt","used":true,"link":"https://aoianz.github.io/tag/TG-Vv40Nt/"}],"title":"HI,陌生人","feature":"","link":"https://aoianz.github.io/post/mate/","stats":{"text":"1 min read","time":9000,"words":48,"minutes":1},"date":"2030-01-01 18:52:06","dateFormat":"2030-01-01"},{"content":"2.1数据库基础知识 1.Dos登录 命令:mysql -h hostname -u username -p 例如:mysql -h 123 -uroot -p 简写:mysql -u root -p 复合主键 就是指你表的主键含有一个以上的字段组成 &gt; create table test &gt; ( &gt; name varchar(19), &gt; id number, &gt; value varchar(10), &gt; primary key (name,id) &gt; ) 上面的name和id字段组合起来就是你test表的复合主键 它的出现是因为你的name字段可能会出现重名，所以要加上ID字段这样就可以保证你记录的唯一性 一般情况下，主键的字段长度和字段数目要越少越好 2.1.1创建和查看数据库 创建数据库 语法:create database 数据库名称; create database itcast;/*创建数据库itcast:*/ 查看数据库 语法:show databases/*查看数据库*/ 查看某个数据库 语法:show create database 数据库名称; 例如:show create database itcase;/*查看数据库itcase信息*/ 使用数据库 语法:use 数据库名称; 例如:use itcast;/*使用数据库itcast*/ 2.1.2修改数据库 alter 数据库名称;修改数据库 语法:alter database 数据库名称 default character set 编码方式 collate 编码方式_bin 例如:修改数据库,将数据库itcast的编码修改为gbk &gt; alter database itcast default character set gbk collate gbk_bin; 2.1.3删除数据库 语法:drop database 数据库名称; 例如:drop database itcast;/*删除名称为itcast的数据库*/ 2.2数据类型 2.2.1 整数类型 1.在MySQL数据库中，经常需要存储整数数值。根据数值取值范围的不同，MySQL中的整数类型可分为5种，分别是 TINYINTtinyint、SMALLINT、 MEDIUMINT、INT和BIGINT。不同整数类型的取值范围可以根据字节数计算出来，例如， TINYINT类型的整数占用1个字节，1个字节是8位，那么，TINYINT类型无符号数的最大值就是28-1，即255。 同理可以算出其它不同整数类型的取值范围。 **注意:**在足够使用的情况下选择选择尽量小的数据类型 2.2.2浮点数类型与定点数类型 2.在MySQL数据库中，存储的小数都是使用浮点数和定点数来表示的。浮点数的类型有两种，分别是单精度浮点数类型(float)和双精度浮点类型(double)。而定点数类型只有decimal，类型。 浮点型:非精准数据类型,有误差 定点型:精准类型 2.2.3日期与时间类型 3.为了方便在数据库中存储日期和时间，MySQL提供了表示日期和时间的数据类型,分别是YEAR、DATE、TIME、DATETIME和timestamp year:1字节 例如:year 2014 ='2014' p35 '00'~'69' 20?? 58= 2058 '70'~'99' 19?? 89 =1989 1.YEAR类型:(字符串类型与数字类型)'2020' 2020 '00-99' 1-99 2.DATE类型: '2020-06-21' '20200621' current_data或now()/表示当前日期/ 3.TIME类型:表示时间值 格式:HH:MM:SS current_data或now()表示当前系统时间 4.DATATIME类型 now()表示当前日期和时间 5.TIMESTAMP类型 与DATATIME类型显示形式相似,但取值范围比DATATIME类型小 2.2.4 字符串和二进制类型 为了存储字符串、图片和声音等数据，MySQL提供了字符串和二进制类型。包括CHAR和VARCHAR类型、BINARY和VARBINARY类型、TEXT类型、BLOB类型ENUM类型、SET类型和BIT类型 1.CHAR和VARCHAR类型: ​ CHAR和VARCHAR类型都用来表示字符串数据,VARCHAR可以储存可变字符串 语法:CHAR(M)或VARVCHAR(M) M指字符串的最大长度; VARCHAR(4)所对应的数据所占用的字节数为实际长度加1; char:浪费时间,但查询速度快; varchar:节约空间,但查询速度慢 '' '' 4个字节 '' 1个字节 'ab' 'ab' 4个字节 'ab' 2个字节 'abc' 'abc' 4个字节 'abc' 3个字节 'abcd' 'abcd' 4个字节 'abcd' 4个字节 'abcdef' 'abcd' 4个字节 'abcd' 5个字节 2.BINARY和VARBINARY类型: ​ BINARY和VARBINARY类型类似CHAR和VARCHAR类型,不同的是,它们表示二进制数据 语法:BINARY(M)或VARBINARY(M) M指二进制数据的最大字节长度; 注意:BINARY类型的长度是固定的,如果数据的长度不足最大长度,将在数据的后面用&quot;\\0&quot;补齐,最终达到指定长度. 例如,指定数据的类型是BINARY(3),当插入a时,实际储存的数据为&quot;a\\0\\0&quot;,当插入ab时,实际储存的数据是&quot;ab\\0&quot;; 3.TEXT类型: TEXT类型用来表示大文本数据,例如,文章内容、评论等,它的类型分为4种; 数据类型 储存范围 数据类型 储存范围 TINYTEXT 0-255字节 MEDIUMTEXT 0-16777215字节 TEXT 0-65535字节 LONGTEXT 0-4294967295字节 4.BLOB类型: ​ BLOB类型是一种特殊的二进制类型,它用于表示数据量大很大的二进制数据,例如 图片、PDF文档等 数据类型 储存范围 数据类型 储存范围 TINYBLOB 0-255字节 MEDIUMBLOB 0-16777215 BIOB 0-65535字节 LONGBILOB 4294967295 注意:BLOB类型数据是根据二进制编码进行比较和排序,而TEXT类型数据是根据文本模式进行比较和排序 5.ENUM类型: ENUM类型又称为枚举类型 ENUM('值1','值2','值3',...'值n') 注意:MYSQL中存入的是这个顺序编号,而不是列表中的值 6.SET类型: SET类型用于表示字符串对象,它的值可以有零个或多个,SET类型数据的定义格式与ENUM类型相似 语法:SET('值1','值2','值3',...'值n') 注意:MYSQL中存入的是这个顺序编号,而不是列表中的值 7.BIT类型: ​ 用于表示二进制数据 语法:BIT(M) M用于表示每个值的位数,范围是1-64; 注意:如果分配的BIT(M)类型的数据的长度小于M,将在数据的左边用0补齐 例如,为BIT(6)分配值b'101'与分配b'000101'相同 2.3创建数据表 create database student;/*创建名为student*/ use itcase;/*使用数据库*/ create TABLE tb_grade/*创建名为tb_gradea的数据表*/ ( id INT(11),/*举例*/ name VARCHER(20), grade FLOAT ); show tables;/*验证数据库是否创建成功*/ show create table tb_greade;/*查看数据表创建时的定义语句,查看表的字符编码*/ describe tb_greade;/*查看表的字段信息,包括字段名、字段类型等信息*/ 修改数据表 ​ 1.修改表名; alter table 表名 rename 新表名; alter table tb_grade rename(to) grade; ​ 2.修改字段名; alter table 表名 change 旧字段名 新字段名 新数据类型; alter table grade change name username verchar(20);/*name字段改为username,数据类型保持不变*/ desc greade;/*验证*/ ​ 3.修改字段的数据类型; alter table 表名 modify 字段名 数据类型; alter table grade modify id int(20);/**/ ​ 4.添加字段; alter table 表名 add 新字段名 数据类型 [约束条件][first|after 已存在的字段名] alter table grade add age int(10); alter table grade add age int(10) first;/*添加到第一位*/ alter table grade add age int(10) after id;/*添加到id后面*/ alter table grade add age int(10) not null first;/*不允许为空*/ ​ 5.删除字段; alter table 表名 drop 字段名; alter table grade drop age; ​ 6.修改字段的排列位置; alter table 表名 modify 字段名1 数据类型 first|after 字段名2; 字段名1 指要修改位置的字段; first是可选参数,指的是将字段1修改为表的第一个字段; after 字段名2 是将字段1插入到字段2后面; alter table grade modify id int(10) after grade;/*将id字段插入到grade字段后面*/ 删除数据表 drop table 表名; drop table grade; desc table grade;/*验证*/ 2.4表的约束 防止数据表中插入错误的数值,而定义的维护数据库完整性的规则 约束条件 说明 PRIMARY KEY 主键约束，用于唯一标识对应的记录(主键唯一表示,值不能为空null ); FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 2.4.1 主键约束; 注意:每个数据表中最多只能有一个主键约束,定义为primary key的字段不能有重复值且不能为null值 1.单字段约束 语法: 字段名 数据类型 PRIMARY KEY 例如:创建一个数据表ex1,并设置id作为主键,SQL语句如下: CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20), grade FLOAT ); 2.多字段主键 语法:PRIMARY KAY(字段名1,字段名2,***字段名n) 例如:创建一个数据表ex2,在表中将stu_id和course_id两个字段共同作为主键,SQL语句如下: CREATE TABLE ex2( stu_id INT, course_id FLOAT, PRIMARY KEY(stu_id,course_id) ); 2.4.2非空约束 非空约束指的是字段的值不能为null,在MySQL中,非空约束是通过NOT NULL定义的; 语法: 字段名 数据类型 NOT NULL; 例如:CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT not null ); 2.4.3唯一约束 保证数据表中字段的唯一性,即表中字段的值不能重复出现 语法: 字段名 数据类型 UNIQUE; CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT UNIQUE ); ID为主键,name的字段不能为空值,grade字段为唯一值,该值不能重复 2.4.4默认约束 用于给数据表中的字段添加指定默认值 语法:字段名 数据类型 DEFAULT 默认值; 例如:CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT default 0/*默认值为0*/ ); 2.5设置表的字段值自动增加 在数据表中，若想为表中插入的新记录自动生成唯一的ID，可以使用AUTO_INCREMENT约束来实现。 AUTO_INCREMENT约束的字段可以是任何整数类型，默认情况下，该字段的值是从1开始自增的 语法: 字段名 数据类型 AUTO_INTCREMENT; 例如:创建一个数据表ex5,将表中的id字段设置为自动增加,SQL语句如下: CREATE TABLE ex1( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) NOT NULL, grade FLOAT UNIQUE ); 2.6索引 2.6.1索引的概念 数据库的索引好比新华字典的音序表，它是对数据库表中一列或多列的值进行排序后的一种结构，其作用就是提高表中数据的查询速度 1.普通索引 普遍索引是由KEY或INDEX定义的索引，它是MySQL中的基本索引类型,可以创建在任何数据类型中，其值是否唯一和非空 由字段本身的约束条件所决定。 2.唯一性索引 唯一性索引是由UNIQUE定义的索引,该索引所在字段的值必须是唯一的。 3.全文索引/文本/ 全文索引是由FULLTEXT定义的索引，它只能创建在CHAR、VARCHAR或TEXT类型的字段上,而且,现在只有MyISAM存储引擎支持全文索引。 4.单列索引 单列索引指的是在表中单个字段上创建索引，它可以是普通索引、唯一索引或者全文索引,只要保证该索引只对应表中一个字段即可。 5.多列索引 多列索引指的是在表中多个字段.上创建索引，只有在查询条件中使用了这些字段中的第一个字段时,该索引才会被使用。 6.空间索引 空间索引是由SPATIAL定义的索引，它只能创建在空间数据类型的字段上。创建时必须声明为not null,并且只有MyISAM存储引擎支持 2.6.2 创建索引 &gt; 1.创建表的时候创建索引 语法:CREATE TABLE 表名(字段名 数据类型 [完整性约束条件], 字段名 数据类型 [完整性约束条件], ... 字段名 数据类型 [UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY [别名] (字段名1 [(长度)] [ASC|DESC]) ); UNIQUE:可选参数，表示唯一索引 FULLTEXT:可选参数，表示全文索引 SPATIAL:可选参数，表示空间索引 INDEX和KEY:用来表示字段的索引，二者选一即可 ASC和DESC可选参数，ASC表示升序排列，DESC表示降序排列 别名:可选参数，表示创建的索引的名称 字段名1:指定索引对应字段的名称， 长度:可选参数，用于表示索引的长度 &gt;1.创建普通索引 mysql&gt; create table t2( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; index index(id asc)/*创建名为index的索引,升序排列*/ -&gt; ); 建立后,使用show create table查看表的结构 ==show create table t1\\G; t1\\G 使排列有序 为了查看索引是否被使用可以使用explain语句进行查看,SQL代码如下: explain select * from t1 while id=1 \\G &gt;2.创建唯一性索引 mysql&gt; create table t2( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; unique index unique_id(id asc)/*在表中id字段上建立索引名为unique_id的唯一性索引,并且按照升序排序*/ -&gt; ); &gt;3.创建全文索引 mysql&gt; create table t1( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; fulltext index fulltext_name(name) -&gt; )engine=myisam;/*因为目前只有MyISAM存储引擎支持全文索引*/ &gt;4.创建单列索引 mysql&gt; create table t4( -&gt;name varchar(20) not null, -&gt; score float, -&gt; index single_name(name(20))/*在name字段上创建一个名叫single_name的单列索引索引长度为20*/ -&gt; ); &gt;5.创建多列索引 mysql&gt; create table t5( -&gt;id int not null, -&gt;name varchar(20) not null, -&gt; score float, -&gt; index multi(id,name(20))/*在id和name字段上创建一个名叫multi的多列索引*/ -&gt; ); 注意:在多列索引中,只有查询条件中使用了这些字段的第一个字段时多列索引才会被使用 &gt;6.创建空间索引 mysql&gt; create table t6( -&gt;id int, -&gt;space geometry not null, -&gt;spatial index sp(space)/*在space字段上建立一个名为sp的空间索引*/ -&gt;)engine=myisam; 注意:创建空间索引时,所在字段不能为空值,并且表的储存引擎为myisam 2.使用CREATE INDEX语句在已经存在的表上创建索引 语法CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 ON 表名 (字段名 [(长度)] [ASC|DESC]); mysql&gt; create table book( -&gt; bookid int not null, -&gt; bookname varchar(255) not null, -&gt; authors varchar(255) not null -&gt; info varchar(255) null, -&gt; comment varchar(255) null, -&gt; publicyear year not null -&gt; ); &gt;1.创建普通索引 mysql&gt; create index index_id on book(bookid);/*在book表中的bookid字段上建立一个名为index_id的普通索引*/ mysql&gt; show create table book\\g;/*查看数据表结构*/ &gt;2.创建唯一性索引 create unique index uniqueidx on book(bookid); /*在bookid字段上创建一个名为uniqueidx的唯一性索引*/ &gt;3.创建单列索引 create index singleidx on book(comment); /*在comment字段上创建一个名称为singleidx的单列索引*/ &gt;4.创建多列索引 create index mulitidx on book(authors(20)),info(20)); /*在authors和info字段上创建一个名称为mulitidx的多列索引*/ &gt;5.创建全文索引 create fulltext index fulltextidx on book(info); /*在info字段上创建名为fulltextidx的全文索引*/ &gt;6.创建空间索引 create table t7( g geometry not null )engine=myisam; create spatail index spatidx on t7(g);/*在g字段上创建名称为spatidx的空间索引*/ 3.使用ALTER TABLE 语句在已经存在的表上创建索引 语法:ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 (字段名[(长度)] [ASC|DESC] ) create table book( bookid int not null, bookname varchar(255) not null, authors varchar(255) null, comment varchar(255) null, pubblicyear year not null ); &gt;1.创建普通索引 alter table book add index id(bookid); &gt;2.创建唯一性索引 alter table book add unique uniqueidx(bookid); &gt;3.创建单列索引 alter table book add index singleidx(comment(50)); &gt;4.创建多列索引 alter table book add index multidx(authors(20),info(50)); &gt;5.创建全文索引 alter table book add fulltext index fulltextidx(info); &gt;6.创建空间索引 create table t8( space geometry not null )engine=myisam; alter table t8 add spatial index spatidx(space); 2.6.3删除索引 &gt; 1.使用alter table删除索引 语法:alter table 表名 drop index 索引名; 例如: 删除表book中名叫fulltextidx的全文索引 alter table book drop index fulltextidx; &gt; 2.使用 drop index删除索引 语法:drop index 索引名 on 表名; 3.1添加数据 &gt; 3.1.1为表中所有字段添加数据; &gt; 1.insert语句中指定所有字段名 向表中添加新记录时,可以在insert语句中列出表中的所以字段名; 注意:必须列出表中所以的字段名称,&quot;值1,值2,..&quot;的顺序,类型必须与对应的字段相匹配 语法:insert into 表名(字段名1,字段名2,...) values(值1,值2,...); 验证数据是否成功使用select语句查看student表中的数据 select * from 表名; &gt; 2.insert语句中不指定字段名 注意:由于insert语句中没有指定字段名,添加的值的顺序必须和字段在定义的顺序相同 语法: insert into 表名 values(值1,值2,...); &gt;3.1.2为表中指定的字段添加数据 语法: insert into 表名(字段1,字段2,...) values(值1,值2) &gt;3.1.3同时添加多条记录 语法:insert into 表名 [(字段名1,字段名2,...)] values(值1,值2,...), (值1,值2,...), (值1,值2,...); 例如: 向student表中添加三条新纪录,insert语句如下: mysql&gt; insert into student values -&gt; (6,'lilei',99), -&gt; (7,'hanmeimei',100), -&gt; (8,'poly',40.5); 3.2更新数据 语法: update 表名 set字段名1=值1[,字段2=值2,...] [where条件表达式] &gt; 1.update 更新部分数据 例如:更新student表中id字段值为1的记录,将记录中的name字段的值更改为'caocao',grade字段的值更改为50; mysql&gt; update student &gt; set name='caocao',grade=50 &gt; where id=1 &gt; 2.update 更新全部数据 例如:将student表中全部记录,将grade字段值都变为100: &gt;update student &gt;set grade=100 3.3 删除数据 delete from 表名[where 条件表达式] &gt;1.删除部分数据 &gt;delete from 表名 &gt;where 条件表达式 例如:删除表student上id字段上小于4的记录 &gt;delete from student &gt;where id&lt;4; &gt;2.删除全部数据 &gt;1.delete delete from 表名; &gt;2.truncate truncate from 表名; 区别: delete语句后跟where子句,可以删除部分记录,truncate只能删除表中全部记录 delete语句删除数据后,再次向表中增加记录时,自动增加字段的值为删除时该字段的最大值加1,truncate语句删除数据后,自动字段的默认初始值重新由1开始; 4.1 简单查询 &gt;4.1.1 select 语句 语法 //顺序不能颠倒 mysql&gt; &gt; select [distinct] * |字段名1,字段名2,字段名3,... &gt; from 表名 &gt; [where 条件表达式1] &gt; [group by 字段名 [having条件表达式2]] &gt; [order by 字段名 [asc|desc]] &gt; [limit [offset] 记录数] &gt;4.1.2 查询所有字段 &gt; 1.在select语句中指定所有字段 语法:select 字段名1,字段名2,...from 表名 &gt; 2.在select语句中使用星号(*)通配符代替所有字段 select * from 表名 &gt;4.1.3 查询指定字段 语法: select 字段名1,字段名2,...from 表名; 4.2 按条件查询 &gt;4.2.1带关系运算符查询 where 子句中指定查询条件对数据进行过滤 语法:select 字段名1,字段名2,... from 表名 where 条件表达式 &gt;4.2.2 带in关键字的查询 in关键字用于判断某个字段的值是否在指定集合中 语法:select * |字段名1,字段名2,... from 表名 where 字段名[not] in (元素1,元素2) &quot;元素1,元素2&quot;表示集合中的元素,即指定的条件范围 not 为可选参数,使用not表示查询不在in关键字指定集合范围的记录 例如:查询student表中ID值为1,2,3的记录 mysql&gt; select id,grade,name,grade from student where id in(1,2,3); &gt;4.2.3带between and 关键字查询 between and 用于判断某个字符的值是否在指定的范围之内,如果字段的值在指定的范围内,则满足条件 select * |{字段名1,字段名2,...} from 表名 where 字段名 [not] between 值1 and 值2 例如: 查询student表中id值在2~5之间的学生姓名 mysql&gt; select id,name from student where id between 2 and 5; &gt;4.2.4 空值查询 在数据表中,某些列的值可能为空值(null),空值不同于0,也不同于空字符串 在mysql中,使用is null关键字来判断是否为空值 语法:select * |字符段1,字符段2,... from 表名 where 字段名 is [not] null; 例如:查询Student表中gender为空值的记录 mysql&gt; select id,name,grade,gender from student where gender is null; &gt;4.2.5 带distinct关键词的查询 很多表中某些字段的数据存在重复的值,使用distinct过滤重复记录的字段 例如:在student表中查询gender(性别)字段的值,查询记录不能重复; mysql&gt; select distinct gender from student; distinct关键字作用于多个字段,如果字段名1字段名2里的值都相同才被认为是重复记录 语法:select distinct 字段名1,字段名2,...from 表名; &gt;4.2.6 带like关键字的查询 使用关系运算符&quot;=&quot;可以判断两个字符串是否相等,但有些需要是对字符串进行模糊查询 select * | {字符段1,字符段2,...} from 表名 where 字段名 [not] like '匹配字符串'; 1. 百分号(%) 通配符 作用 : 匹配任意长度的字符串 ,包括空字符串 例1: 查询student表中name字段值以字符&quot;s&quot;开头的学生 id mysql&gt; select id, name from student where name like &quot;s%&quot; ; 例2:查询student表中name字段值以字符&quot;w&quot;开头,以字符&quot;g&quot;结束的学生 id mysql&gt; select id, name from student where name like &quot;w%g&quot; ; 例3:查询student表中name字段值包括字符&quot;y&quot;的学生 id; mysql&gt; select id, name from student where name like &quot;%y%&quot; ; 2. 下划线(_) 通配符 作用 : 下划线通配符只能匹配单个字符,如果需要匹配多个则需要使用多个下划线 例1: 查询student表中name字段值以字符串&quot;wu&quot;开始, 以字符串&quot;ong&quot;结尾,并且两个字符串之间只有一个字符的记录 mysql&gt; select * from student where name like &quot;wu_ong&quot;; 例2: 查询student表中name字符值包括7个字符, 并且以字符串&quot;ing&quot;结尾的记录 mysql&gt; select * from student where name like &quot;_______ing&quot;; 3.使用百分号和下划线通配符进行查询操作 作用 : 通过右斜线( &quot; \\ &quot; )对百分号和下划线进行转义 例如 : &quot;%&quot;匹配百分号字符值 , &quot; \\ _ &quot;匹配下划线字符值 例如: 查询student表中name字段值包括&quot;%&quot;的记录; mysql&gt; insert into student (name,grade,gender) -&gt; values ('sun%er',95,'男'); mysql&gt; select * from student where name like &quot;%\\%%&quot;; &gt;4.2.7 带and关键字的多条件查询 and关键字连接两个或以上查询条件 例如:select * from 表名 where 条件表达式1 and 条件表达式2 [...and 条件表达式n] 查询student表中id字段值在1.2.3.4之中,name字符值以字符串'ng'结尾,并且grade字段值小于80的记录 mysql&gt; select id,name,grader,gender -&gt; from student -&gt; where id in(1,2,3,4) and name like '%ng' and grade &lt;80; &gt;4.2.8 带or关键字的多条件查询 or关键字满足一个,可以连接两个或多个查询条件 例如:查询student表中满足条件name字段值以字符'h'结束,或者gender字符值为'女',或者grade字段值为100的记录 mysql&gt; select id,name,grade,gender -&gt; from student -&gt; where name like '%h' or gender='女' or grade=100; 注意:or和and可以一起使用, and优先级高于or 例如:查询student表中student字符值为'女'或者gender字符值为'男',并且gender字段值为100的学生姓名 mysql&gt; select name,grade,gender -&gt; from student -&gt; where gender='女' or gender ='男' and grade=100; 4.3 高级查询 &gt;4.3.1 聚合函数 &gt;1.count()函数 COUNT()函数用来统计记录的条数，其语法格式如下所示: SELECT COUNT(*) FROM 表名; 例如: 查询student表中一共有多少条记录 mysql&gt; select count(*) from student; &gt;2.sum()函数 SUM()是求和函数，用于求出表中某个字段所有值的总和，其语法格式如下: SELECT SUM(字段名) FROM 表名 例如:求出student表中grade字段的总和 mysql&gt; select sum(grade) from student7 &gt;3.avg()函数 AVG()函数用于求出某个字段所有值的平均值其语法格式如下所示: SELECT AVG(字段名) FROM student; 例如:求出student表中grade字段的平均值 &gt;select avg(grade) from student &gt;4.max()函数 MAX()函数是求最大值的函数，用于求出某个字段的最大值，其语法格式如下所示: SELECT MAX(grade) FROM student; 例如:求出student表中grade字段的最大值 &gt;select max(grade) from student &gt;5.min()函数 MIN()函数是求最小值的函数，用于求出某个字段的最小值，其语法格式如下所示: SELECT MIN(grade) FROM student; 例如:求出student表中grade字段的最小值 &gt;select min(grade) from student &gt;4.3.2 对查询结果排序 ​ 从表中查询出来的数据可能是无序的,或者排列顺序不是用户期望的,为了使查询结果满足用户的要求,可以使用order by ​ 对查询结果进行排序,语法格式如下: 使用 ORDER BY对查询结果进行排序其语法格式如下所示: SELECT字段名1, 字段名2, FROM 表名 ORDER BY字段名1 [ASC|DESC]，字段名2 [ASC|DESC] /*asc:升序,从小到大,desc:倒叙,从大到小*/ 例2:查询student表中的所有记录,按照gender字段的升序和grade字段的降序进行排序: mysql&gt; select * from student -&gt; order by gender asc, grade desc; ==注意:==在按照指定字段进行升序排列时，如果某条记录的字段值为NULL，则这条记录会在第一条显示，这是因为NULL值可以被认为是最小值 &gt; 4.3.3 分组查询 &gt;1.单独使用group by 分组 单独使用group by 关键词,查询的是每个分组的一条记录 例如:查询student表中的记录,按照gender字段值进行分组 select * from student group by gender; 查询结果是按照gender字段中的不同值进行分类的,查询结果只显示每个分组 &gt;2.group by和聚合函数一起使用 gruop by 和聚合函数一起使用可以统计出某个或者某些字段在一个分组中的最大值,最小值,平均值等 例如:将student表中gender字段值进行分组查询,计算出每个分组中各有多少名学生 select count(*),gender from student group by gender; 例如:将student表中gender字段值进行分组查询,计算出每个分组的总成绩,平均成绩,最高分,最低分 select sum(grade),avg(grade),max(grade),min(grade),genter from student3 group by genter; &gt;3. group by 和 having关键词一起使用 having关键字和 where关键字的作用相同,都设置条件表达式对查询结果进行过滤,两者区别在于, having关键字后可以跟聚合函数,而where 关键字不能 例如:将student表中按照gender字段进行分组查询,查找grade字段值之和小于300的分组 select student sum(grade),gender from student group by gender having sum(grade)&lt;300 &gt;4.3.4 使用limit限制查询结果的数量 查询数据时,可能会返回很多条记录,而用户需要的记录可能只是其中的一条或者几条,比如实现分页功能,每页显示10行信息,每次查询都需要查出10条记录 格式:select 字段名1,字段名2,... from 表名 limit [offset,] 记录数 //limit后可以跟两个参数,第一个参数offset表示偏移量,如果为0则从查询结果的第一条开始记录,偏移量为1则从查询结果中的第二条记录开始,以此类推;offset为可选值,如果不指定其默认值为0.第二个参数&quot;记录数&quot;表示返回查询记录的条数; 例(1):查询Student表中的前四条记录 select * from student limit 4; //没有指定返回记录的偏移量,只指定了查询记录的条数4,因此返回结果从第一条开始,一共返回4条记录; 例(2):查询student表中grade字段值从第五位到第八位的学生(从高到低) select * from student group desc limit 4,4 limit后面第一个参数表示偏移量位4,即从第五条开始查询,第二个参数表示一共返回4条记录,即从第五位到第8为学生 &gt;4.3.5 函数(列表) 函数名称 作用 ABS(x) 返回x的绝对值 SQRT(x) 返回x的非负2次方根 MOD(xy) 返回x被y除后的余数 CEILING(x) 返回x的绝对值 FLOOR(z) 返回x的绝对值 ROUND(x,y) 返回x的绝对值 TRUNCATE(x) 返回x的绝对值 SIGN(x)2 返回x的绝对值 4.4 为表和字段取别名 &gt; 4.4.1 为表取别名 在查询操作时,如果表名很长使用起来就不太方便,这时可以为表取一个别名,用这个别名来代替表的名称; 语法: select * from 表名 [as] 别名; as关键字用于指定表名的别名,它可以省略不写; 例如: 为student表起一个别名 s,并查询student表中gender字段值为'女'的记录 select * from student as s where s.gender='女'; student as s表示student表的别名为s s.gender 表示student表中的gender字段; &gt; 4.4.2 为字段取别名 为了让显示查询结果更加直观,可以为字段取一个别名 select 字段名 [as] 别名 [,字段名 [as] 别名,...] from 表名; 例如:查询student表中的所有记录的name和grade字段值,并为这两个字段名起别名stu_name和stu_genter; select * from name as stu_name, grader as stu_genter from student; 5.1 外键 &gt; 5.1.1 什么是外键 外键是指引用另一个表中的一列或多列,==被引用的列应该具有主键约束或唯一性约束.==外键用来建立和加强两个表数据之间的连接 引入外键后,外键列只能插入参照列存在的值,参照列被参照的值不能被删除,这就确保了数据的参照完整性 创建两个表,一个班级表(grade),一个学生表(student) create table grade( id int(4) not null primary key, name varchar(36) ); create table student( sid int(4) not null primary key, sname varchar(36), gid int(4) not null ); 学生表(student)中的gid 是学生所在的班级id,是引入了班级表(grade) 中的主键id,那么gid就可以作为表student的主键..被引用的表,即表grade是主表;引用外键的表,即表student是从表,两个表是主从关系. 表student用gid可以连接表grade中的信息 &gt;5.1.2 为表中添加外键约束 语法: alter table 表名 add constraint FK_ID foreign key(外键字段名) references 主表表名(主键字段名); 语句: alter table student add constraint FK_ID foreign key(gid) references grade(id); &gt;5.1.3 删除外键约束 在实际开发中,根据业务逻辑的需求,需要解除两个表的关联关系时, 就需要删除外键约束 语法: alter table 表名 drop foreign key 外键名; 接下来,将表中student表的外键约束删除 alter table student drop foreign key FK_ID; 5.2 操作关联表 &gt;5.2.1 关联关系 1.多对一 (外键定义在多端) 一个部门可以有多个员工，而一个员工不能属于多个部门。 在多对一的表关系中，应该将外键建在多的一方 2.多对多 (需定义中间表) 一个老师可以教多个学生，同时一个学生可以上多个老师的课程。 为了实现数据表多对多的关系，需要定义一张第三方中间表，该表保存两个关系表的外键。 3.一对一 (从表依赖主表) 一对一的对应关系中，需要分清主从关系，通常在从表中建立外键 &gt;5.2.2 添加数据 在开发中，最常见的关联关系就是多对一关系 为表student和表grade中添加外键约束来建立两个表的关联关系 alter table student add constraint FK_ID foreign key(gid) references grade (id); &gt;5.2.3 删除数据 由于grade表与student表之间具有关联关系 , 参照列被参照的值不能被删除的,再删除软件二班时需要删除软件二班的所有学生 delete from student where sname='王红'; delete from student where sname='李强'; delete * from grade where id=2; 5.3 连接查询 &gt; 5.3.1交叉连接 交叉连接返回的结果是被连接的两个表中所有数据行的笛卡尔积即行数的乘积 例如:department表中有4个部门,employee表中有4个员工,那么交叉连接的结果就有4X4=16条数据 语法: select *from 表1,表2; 或select * from 表1 cross join 表2; &gt; 5.3.2 内连接 内连接（INNER JOIN）又称简单连接或自然连接，内连接使用比较运算符对两个表中的数据进行比较，列出与连接条件匹配的数据行，组合成新的记录 简单连接或自然连接,返回的结果是两个表中一一对应的数据,只有满足条件的数据才显示 语法:select 查询字段 from 表1[inner] join 表2 on 表1.关系字段= 表2.关系字段 例如: 在department表和employee表之间使用内连接查询; select employee.name,department.dname from department inner join employee on department.did=employee.did; //只有department.did和employee.did相等的才输出 使用where条件语句来实现同样的功能; 例如:在department表和employee表之间使用where: select employee.name, department.dname from department,employee where department,did=employee.did; 注意:where子句的查询结果与使用inner join的查询结果是一致的,虽然结果相同,但inner join 是内连接语句,where是条件判断语句,在where语句后可以添加其他条件,而inner join语句不可以; 如果在一个连接查询中,涉及的两个表是同一个表,这种查询称为自连接查询,指的是相互连接的表在物理上为同一个表,但逻辑上分为两个表 查询部门为2的员工的姓名和年龄; select department.did,employee.name,employee.age from department join employee on department.did=employee.did where department.did=2; 或 select department.did,employee.name,employee.age from department,employee where department.did=employee.did and department.did=2; 查询姓名为王红所在的部门编号和部门名称 select employee.name,department.did,department.dname from department,employee where department.did=employee.did and employee.name='王红'; 自连接: 例如:在department表和employee表之间使用自连接查询王红所在的部门有哪些员工; select p1.* from employee p1 inner join employee p2 on p1.did=p2.did where p2.name='王红'; /*p1 p2为别名*/ 或select p1.* from employee p1,employee p2 where p1.did=p2.did and p2.name='王红';/*where方法*/ &gt; 5.3.3 外连接 外连接分为左连接和有连接 左连接的结果包括LEFT JOIN子句中指定的左表的所有记录，和所有满足连接条件的记录。如果左表的某条记录在右表中不存在，则在右表中显示为空 ; 右连接与左连接正好相反，返回右表中所有指定的记录和所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值 ; 做外链接:左表中的所有记录以及内连接的记录(放在前面的是左表) 右外连接:右表中的所有记录以及内连接的记录 语法: SELECT 所查字段 FROM 表1 LEFT|RIGHT [OUTER] JOIN 表2 ON 表1.关系字段 = 表2.关系字段 WHERE 条件 select * from 表1,表2 where表1.关系字段=表2.关系字段 and 其他条件 &gt;全外连接查询 在外连接的基础上,增加左边表有,右边表没有的记录,以及右边表有左边表没有的记录 语法: select * from 表1 full jion 表二 on 表一.关系字段=表二.关系字段; select * from dep full jion emp on dep.did=em.did; &gt;5.3.4 复合条件查询 5.4 子查询 &gt;5.4.1 带IN关键字的子查询 使用in关键字进行子查询时,内层查询语句仅返回一个数列值,这个数列值中的值将供外层查询语句进行比较操作 例如:查询存在年龄为20岁的员工的部门 select * from department where did in(select did from employee where age=20); 或 //子查询方法 select department.did,department.dname from department join employee on department.did=employee.did where employee.age=20; //内连接方法 或 select department.did,department.dname from department,employee where department.did=employee.did and employee.age=20; //where方法 &gt;5.4.2 带exists关键字的子查询 exists关键字后面的参数可以是任意一个子查询,这个子查询的作用相当于测试,他不产生任何数据,只返回true或false,当返回值为true时,外层查询才会执行 例如:查询employee表中是否存在年龄大于21岁的员工,如果存在,则查询department表中的所有记录 select * from department where exists(select did from employee where age&gt;21); &gt; 5.4.3 带any关键字的子查询 any关键字表示满足其中任意一个条件,它允许创建一个表达式对子查询的返回值列表进行比较 例如: select * from department where did&gt;any(select did from employee);//列出只要大于employee.did任意一个数 &gt;5.4.4 带all关键字的子查询 例如: select * from department where did&gt;all(select did from employee);/列出大于employee.did所有的数 &gt;5.4.5 带比较运算符的子查询 比较运算符 &gt; , &lt; , = , &gt;= , &lt;= , ! = 例如:使用比较运算符的子查询,查询赵四是哪个部门的员工 select * from department where did=(select did from employee where name =&quot;赵四&quot;); 6.1 事务管理 &gt; 6.1.1 事务的概念 所谓的事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，即事务中的语句要么都执行，要么都不执行 开启事务的语法: start transaction 上述语句用于开启事务,事务开启之后就可以执行SQL语句,SQL语句执行成功后,需使用相对应语句提交事务,语法如下: 提交事务的语法: commit 在操作一个事务时,如果发现当前事务中的操作是不合理的,此时只要还没有提交事务,就可以通过回滚来取消当前事务 事务回滚语句: rollback 6.2 存储过程的创建 &gt; 6.2.1 创建存储过程 存储过程就是一条或多条SQL语句的集合，当对数据库进行一系列复杂操作时，存储过程可以将这些复杂操作封装成一个代码块，以便重复使用，大大减少数据库开发人员的工作量 语法格式: CREATE PROCEDURE sp_name([proc_parameter]) [characteristics…]routine_body CREATE PROCEDURE：为用来创建存储过程的关键字。 sp_name: 为存储过程的名称。 proc_parameter: 为指定存储过程的参数列表。 characteristics : 用于指定存储过程的特性。 演示存储过程的创建 1.首先创建一个student表: mysql&gt; create table student( -&gt; id int(3) primary key auto_increment, -&gt; name varchar(20) not null, -&gt; grade float, -&gt; gender char(2) -&gt; ); 2.插入数据 mysql&gt; insert into student(name,grade,gender) -&gt; values('tom',60,'男'), -&gt; ('jack',70,'男'), -&gt; ('rose',90,'女'), -&gt; ('lucy',100,'女'); 3.创建一个查看student表的存储过程 创建一个存储过程proc,每次调用这个存储过程的时候都会执行select语句查看表的内容 mysql&gt; delimiter // --------&gt; 作用: 将MySQL的结束符设置为 // mysql&gt; create procedure proc() -&gt; begin -&gt; select * from student; -&gt; end // &gt; 6.2.2 变量的使用 在MySQL中, 变量可以在子程序中声明, 用于保存数据处理过程中的值, 这些变量的作用范围在BEGIN…END程序中 语法格式: DECLARE var_name[,varname]…date_type[DEFAULT value]; 例如: 定义一个名称为v1的变量，类型为INT类型，默认值为100,查询这个变量的值 mysql&gt; delimiter // mysql&gt; create procedure proc2() -&gt; begin -&gt; declare v1 int default 100; -&gt; select v1; -&gt; end // mysql&gt; delimiter ; mysql&gt; call proc2(); +------+ | v1 | +------+ | 100 | +------+ 例如: 声明三个变量,使用set为变量赋值 mysql&gt; delimiter // mysql&gt; create procedure proc2() -&gt; begin -&gt; declare v1,v2,v3 int; -&gt; set v1=10,v2=20; -&gt; set v3=v1+v2; -&gt; select v1,v2,v3; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc2(); +------+------+------+ | v1 | v2 | v3 | +------+------+------+ | 10 | 20 | 30 | +------+------+------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) 除了使用set语句为变量赋值外,MySQL中还可以通过select...into为一个或多个变量赋值, 该语句可以把选定的列直接储存到对应的位置的变量 语法格式如下: select col_name[...] into var_name [...] table_expr 上述语法格式中,col_name表示字段名称;var_name表示定义的变量名称,table_expr 表示查询条件表达式,包括表名称和where子句. 例如: select grade, gender into s_grade, s_gender from student where name= 'rose' ; 例:声明变量s_grade 和 s_gender,通过select ...into 语句 查询指定记录并为变量赋值 注意: 查询时如果不执行 select s_grade,s_gender; 则无返回结果 mysql&gt; delimiter // mysql&gt; create procedure proc4() -&gt; begin -&gt; declare s_grade float; -&gt; declare s_gender char(4); -&gt; select grade,gender into s_grade,s_gender from student where name='rose'; -&gt; select s_grade,s_gender; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; call proc4()// +---------+----------+ | s_grade | s_gender | +---------+----------+ | 90 | 女 | +---------+----------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 6.2.3 定义条件和处理程序 &gt; 1.定义条件 定义条件是指事先定义程序执行过程中遇到的问题。定义条件使用DECLARE语句，语法格式如下： DECLARE condition_name CONDITION FOR [condition_type]; // condition_type的两种形式： [condition_type]: SQLSTATE[VALUE] sqlstate_value|mysql_error_code condition_name：表示所定义的条件的名称； condition_type：表示条件的类型； sqlstate_value和mysql_error_code：表示MySQL的错误，sqlstate_value是长度为5的字符串类型错误代码，mysql_error_code为数值类型的错误代码。例如：ERROR1142（42000）中，sqlstate_value的值是42000，mysql_error_code的值是1142 例如 // 方法一: 使用sqlstate_value declare commad_not_allowed condition for sqlstate '42000'; // 方法二: 使用 mysql_error_code declare commad_not_allowed condition for 1064; &gt; 2. 定义处理程序 处理程序定义了在程序执行过程中遇到问题时应当采取的处理方式，并且保证存储过程在遇到警告或错误时能继续执行处理过程使用DECLARE语句定义，语法格式如下 : DECLARE handler_type HANDLER FOR condition_value[,…] sp_statement handler_type: CONTINUE|EXIT|UNDO condition_value: //包括5个字符的字符串错误值 ; |condition_name //表示declare condition 定义的错误条件名称 |SQLWARNING //匹配所有以01开头的sqlstate错误代码 |NOT FOUND //匹配所有以02开头的sqlstate错误代码 |SQLEXCEPTION //匹配所有没有被sqlwarning 或 not found捕获的sqlstate错误代码 |mysql_error_code //匹配数值类型错误代码 handler_type：为错误处理方式，参数取值 有3个：CONTINUE、EXIT和UNDO。CONTINUE：表示遇到错误不处理，继续执行； EXIT：遇到错误马上退出。 UNDO：表示遇到错误后撤回之前的操作，MySQL中暂时不支持这样的操作。sp_statement：参数为程序语句段，表示在遇到定义的错误时，需要执行的存储过程。 condition_value：表示错误类型 例如 : // 方法一:捕获sqlstate_value declare continue handler for sqlstate '42S02' set @info = 'no_such_table'; // 方法二:捕获mysql_error_code declare continue handler for 1146 set @info = 'no_such_table' // 方法三:先定义条件,然后调用 declare continue handler for no_such_table set @info='error'; // 方法四:使用sqlwarning declare exit handler for sqlwarning set @info='error'; // 方法五:使用not found declare exit handler for not found set @info='no_such_table'; // 方法六:使用sqlexception declare exit handler for sqlexception set @info='error'; &gt; 6.2.4 光标的使用 在编写存储过程时，查询语句可能会返回多条记录，如果数据量非常大，则需要使用光标来逐条读取查询结果集中的记录。光标是一种用于轻松处理多行数据的机制 &gt; 1. 光标的声明 想要使用光标处理结果集中的数据, 需要先声明光标 。光标必须声明在声明变量, 条件之后 语法: DECLARE cursor_name CURSOR FOR select_statement cursor_name表示光标的名称; select_statement表示select语句的内容, 返回一个用于创建光标的结果集 例如: 声明一个名为cursor_student的光标 DECLARE cursor_student CURSOR FOR select s_name,s_gender FROM student; &gt; 2. 光标的使用 首先要打开光标 语法: open cursor_name; select cursor_name into var_name[,var_name]... cursor_name 表示参数的名称; var_name 表示将光标中的select语句查询出来的信息存入该参数中, 需要注意的是, var_name必须在声明光标之前就定义好 例如: 使用名称为cursor_student的光标, 将查询出来的信息存入s_name和s_gender中 fetch cursor_student into s_name, s_gender; &gt; 3. 光标的关闭 使用完光标后要将光标关闭, 关闭光标的语法格式为 close cursor_name; &gt; 6.2.5 流程控制的使用 流程控制语句用于将多个sql语句划分或组合成符合业务逻辑的代码块 &gt;1. if语句 是指如果条件满足 mysql&gt; delimiter // mysql&gt; create procedure proc6() //定义一个存储过程; -&gt; begin //开始; -&gt; declare var int; //定义一个变量 var; -&gt; set var=10; //设置var的值,可不设置; -&gt; if var is null //if语句开始; -&gt; then select 'val is null'; -&gt; else select 'val is not null'; -&gt; end if; //if语句结束; -&gt; end // //结束; Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc6(); //查看 +-----------------+ | val is not null | +-----------------+ | val is not null | +-----------------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) &gt; 2. case 语句 mysql&gt; delimiter // mysql&gt; create procedure proc7() -&gt; begin -&gt; declare var int; -&gt; set var=1; -&gt; case var -&gt; when 1 then select 'val is 1'; -&gt; when 2 then select 'val is 2'; -&gt; else select 'val is not 1 or 2'; -&gt; end case; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc7(); +----------+ | val is 1 | +----------+ | val is 1 | +----------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 3.loop 语句 loop循环语句用来重复执行某些语句,并不会进行条件判断。 loop语句内的语句会一直重复执行直到跳出循环语句 基本语法如下 : [loop_label:]LOOP // loop_label 表示loop语句的标记名称,该参数可以省略 statement_list // statement_list 表示需要循环执行的语句 END LOOP [loop_label] &gt; 4. leave语句 当不满足循环条件时, 需要用leave语句退出循环 语法: leave label 例如: mysql&gt; create procedure proc8() -&gt; begin -&gt; declare id int default 0; -&gt; add_loop:LOOP -&gt; set id=id+1; -&gt; if id&gt;=10 then leave add_loop; -&gt; end if; -&gt; end LOOP add_loop; -&gt; select id; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; call proc8() // +------+ | id | +------+ | 10 | +------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 5. iterate 语句 mysql&gt; delimiter // mysql&gt; create procedure proc9() -&gt; begin -&gt; declare p1 int default 0; //p1初始值为0; -&gt; my_loop:loop -&gt; set p1=p1+1; -&gt; if p1&lt;10 then iterate my_loop; //如果p1的值小于10是,重复执行p+1 -&gt; elesif p1&gt;20 then leave my_loop; //当p1的值大于或等于10并且小于20时 -&gt; end if; -&gt; select 'p1 is between 10 and 20'; //当p1的值大于或等于10并且小于20时,打印&quot;p1 is bet...&quot; -&gt; end loop my_loop; -&gt; end // &gt; 6. repeat 语句 作用: 创建一个带有条件判断的循环过程, 每次语句执行完毕后, 会对条件表达式进行判断, 如果表达式为真, 则循环结束; 否则重复执行循环中的语句 语法: [repeat_lable:] repeat //repeat_label为repeat语句的标注名称,该参数可选 statement_list utill expr_condition //reapeat语句内的语句或语句群被重复,直至expr_condition为真 end repeat [repeat_lable] 例如 mysql&gt; create procedure proc40() -&gt; begin -&gt; declare id int default 0; -&gt; repeat // -&gt; set id=id+1; -&gt; select id; //遍历 1-10; -&gt; until id&gt;=10 ---------&gt;&gt; 不带分号 -&gt; end repeat; // -&gt; end // Query OK, 0 rows affected (0.00 sec) &gt; 7. where 语句 作用: 创建一个带条件判断的循环过程, 与repeat 不同的是, where在语句执行时, 先对指定的表达式进行判断, 如果为真, 则执行循环内的语句, 否则退出循环 语法: [where_lable:] where expr_condition DO Statement_list end where [where_lable] mysql&gt; create procedure proc42() -&gt; begin -&gt; declare i int default 0; -&gt; while i&lt;10 do -&gt; set i=i+1; -&gt; select i; //遍历1-10; -&gt; end while; -&gt; end // Query OK, 0 rows affected (0.01 sec) 6.3 存储过程的使用 &gt; 6.3.1 调用存储过程 1.定义存储过程 mysql&gt; create procedure test2(in s_gender varchar(50),out num int ) -&gt; begin -&gt; select count(*) into num from student where gender=s_gender; -&gt; end // Query OK, 0 rows affected (0.00 sec) 2调用存储过程 mysql&gt; delimiter ; mysql&gt; call test2(&quot;女&quot;,@num); Query OK, 1 row affected (0.01 sec) 3.查看返回结果 mysql&gt; select @num; +------+ | @num | +------+ | 2 | +------+ 1 row in set (0.00 sec) &gt;6.3.2 查看存储过程 &gt; 1. show status 语句中查看存储过程的状态 mysql&gt; show procedure status like 'proc%' \\G *************************** 1. row *************************** Db: chapter06 Name: proc Type: PROCEDURE Definer: root@localhost Modified: 2020-11-25 08:32:11 Created: 2020-11-25 08:32:11 Security_type: DEFINER Comment: character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci *************************** 2. row *************************** Db: chapter06 Name: proc1 Type: PROCEDURE Definer: root@localhost Modified: 2020-11-25 09:15:20 Created: 2020-11-25 09:15:20 Security_type: DEFINER Comment: character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci &gt; 2. show create 语句中查看存储过程的状态&amp;创建语句 mysql&gt; show create procedure chapter06.proc1 \\G *************************** 1. row *************************** Procedure: proc1 sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `proc1`() begin select * from student; end character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci 1 row in set (0.00 sec) &gt; 3.从information_schema.Routine 表中查看存储过程的信息 mysql&gt; select * from information_schema.Routines -&gt; where routine_name='proc1' -&gt; and routine_type='procedure' \\G *************************** 1. row *************************** SPECIFIC_NAME: proc1 ROUTINE_CATALOG: def ROUTINE_SCHEMA: chapter06 ROUTINE_NAME: proc1 ROUTINE_TYPE: PROCEDURE DATA_TYPE: CHARACTER_MAXIMUM_LENGTH: NULL CHARACTER_OCTET_LENGTH: NULL NUMERIC_PRECISION: NULL NUMERIC_SCALE: NULL CHARACTER_SET_NAME: NULL COLLATION_NAME: NULL DTD_IDENTIFIER: NULL ROUTINE_BODY: SQL ROUTINE_DEFINITION: begin select * from student; end EXTERNAL_NAME: NULL EXTERNAL_LANGUAGE: NULL PARAMETER_STYLE: SQL IS_DETERMINISTIC: NO SQL_DATA_ACCESS: CONTAINS SQL SQL_PATH: NULL SECURITY_TYPE: DEFINER CREATED: 2020-11-25 09:15:20 LAST_ALTERED: 2020-11-25 09:15:20 SQL_MODE: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION ROUTINE_COMMENT: DEFINER: root@localhost CHARACTER_SET_CLIENT: gbk COLLATION_CONNECTION: gbk_chinese_ci DATABASE_COLLATION: utf8_general_ci 1 row in set (0.01 sec) 根据学号查询 mysql&gt; delimiter // mysql&gt; create procedure proc43(in myid int) -&gt; begin -&gt; select name from student where id=myid; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc43(1) ; +------+ | name | +------+ | tom | +------+ 根据输入的ID从学生表中查询该ID对应的姓名,并输出姓名 mysql&gt; delimiter // mysql&gt; create procedure test1(in myid int,out myname varchar(36)) -&gt; begin -&gt; select name into myname from student where id=myid; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call test1(3,@myname) ; //调用存储过程 Query OK, 1 row affected (0.00 sec) mysql&gt; select @myname ; //查看返回结果 +---------+ | @myname | +---------+ | rose | +---------+ 1 row in set (0.00 sec) &gt; 6.3.3 修改存储过程 在MySQL中可以使用alter语句修改存储过程 语法格式如下: ALTER {PROCEDURE|FUNCTION} sp_name[characteristic…] sp_name：表示存储过程或函数的名称。characteristic：表示要修改存储过程的哪个部分 characteristic 的取值如下: 1.contains sql 表示子程序中包括sql语句, 但不包含读或写数据的语句; 2.no sql 表示子程序中不包括sql语句; 3.reads sql data 表示表示子程序中包括读数据的语句; 4.modifies sql data 表示子程序中包括写数据的语句; 5.sql security{definer|invoker} 指明谁有权限来执行; 6.definer 表示只有定义者自己才能执行; 7.invoker 表示调用者可以执行; 8.comment 'string' 表示注释信息; 注意: 目前此版本Mysql还不提供对已存在的存储过程代码的修改, 如果一定要修改存储过程代码, 必须先将存储过程删除之后, 再重新编写代码, 或创建一个新的存储过程 &gt; 6.3.4 删除存储过程 在MySQL中使用DROP语句修改存储过程，语法如下: DROP{ procedure|function }[if exists] sp_name if exists 表示如果程序不存在, 它可以避免发生错误, 产生一个警告 7.1 视图概述 ​ 视图是从基本表中导出来的表，是一种虚拟存在的表, 并且表的结构和数据都依赖于基本表 通过视图不仅可以看到放在基本表中的数据, 并且还可以像操作基本表一样, 对视图中存放的数据进行查询 删除,修改 .与直接操作表相比视图具有以下优点: 1.简化查询语句 日常开发中我们可以将经常使用的查询定义为视图，从而使用户避免大量重复的操作。 2安全性 通过视图用户只能查询和修改他们所能见到的数据，数据库中的其他数据则既看不到也取不到。 3逻辑数据独立性 视图可以帮助用户屏蔽真实表结构变化带来的影响。 7.2 视图管理 &gt; 7.2.1 创建视图的语法格式: create [or replace] [algorithm={undefined | merge | temptable] view view_name [(column_list)] as select_statement [where [cascaded|local] check option] CREATE：表示创建视图的关键字。 OR REPLACE：表示该语句能够替换已有视图。 ALGORITHM：可选，表示视图选择的算法。 UNDEFINED：表示MySQL将自动选择所要使用的算法。 MERGE：使得视图定义的某一部分取代语句的对应部分。 TEMPTABLE：表示将视图的结果存入临时表，然后使用临时表执行语句。 view_name：表示要创建的视图名称。 column_list：可选，表示属性清单。 AS：表示指定视图要执行的操作。 SELECT_statement：表示从某个表或视图中查出满足条件的记录，并导入视图中。 WITH CHECK OPTION：可选，表示创建视图时要保证在该视图的权限范围之内。 CASCADED：需要满足跟该视图有关的所有相关视图和表的条件，该参数为默认值。 LOCAL：可选。表示创建视图时，只要满足该视图本身定义的条件即可。 &gt;7.2.2 在单标上创建视图 在student表上创建view_stu视图和view_stu2视图(自定义字段名) 1.创建数据库,表,插入数据 mysql&gt; create database chapter07; Query OK, 1 row affected (0.04 sec) mysql&gt; use chapter07 Database changed mysql&gt; create table student( -&gt; s_id int(3), -&gt; name varchar(20), -&gt; math float, -&gt; chinese float -&gt; ); Query OK, 0 rows affected (0.05 sec) mysql&gt; insert into student(s_id,name,math,chinese) values -&gt; (1,'Tom',80,78), -&gt; (2,'Jack',70,80), -&gt; (3,'Lucy',97,95); Query OK, 3 rows affected (0.05 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from student; +------+------+------+---------+ | s_id | name | math | chinese | +------+------+------+---------+ | 1 | Tom | 80 | 78 | | 2 | Jack | 70 | 80 | | 3 | Lucy | 97 | 95 | +------+------+------+---------+ 3 rows in set (0.00 sec) 2.创建视图并查询 mysql&gt; create view view_stu as select math,chinese,math+chinese from student; mysql&gt; select * from view_stu; +------+---------+--------------+ | math | chinese | math+chinese | +------+---------+--------------+ | 80 | 78 | 158 | | 70 | 80 | 150 | | 97 | 95 | 192 | +------+---------+--------------+ 3 rows in set (0.00 sec) mysql&gt; create view view_stu2(math,chinese,sum) as select math,chinese,math+chinese from student; Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from view_stu2; +------+---------+------+ | math | chinese | sum | +------+---------+------+ | 80 | 78 | 158 | | 70 | 80 | 150 | | 97 | 95 | 192 | +------+---------+------+ 3 rows in set (0.00 sec) &gt; 7.2.3 在多表上创建视图 在student表和stu_info表中创建stu_class视图, 查询s_id号,姓名和班级 1.创建数据库,表,插入数据 mysql&gt; create table stu_info( -&gt; s_id int(3), -&gt; class varchar(50), -&gt; addr varchar(100) -&gt; ); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into stu_info(s_id,class,addr) values -&gt; (1,'erban','anhui'), -&gt; (2,'sanban','chongqing'), -&gt; (3,'yiban','shandong'); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from stu_info; +------+--------+-----------+ | s_id | class | addr | +------+--------+-----------+ | 1 | erban | anhui | | 2 | sanban | chongqing | | 3 | yiban | shandong | +------+--------+-----------+ 3 rows in set (0.00 sec) 2.创建视图并查询 mysql&gt; create view stu_class(id,name,class) as select student.s_id,student.name,stu_info.class from student,stu_info where student.s_id=stu_info.s_id; Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from stu_class; +------+------+--------+ | id | name | class | +------+------+--------+ | 1 | Tom | erban | | 2 | Jack | sanban | | 3 | Lucy | yiban | +------+------+--------+ 3 rows in set (0.00 sec) &gt; 7.2.4 查看视图 &gt; 1. 使用describe 语句查看视图 作用: 使用DESCRIBE语句可以查看视图的字段信息 语法: DESCRIBE 视图名; 或 DESC 视图名; 例如: desc[describe] stu_class; &gt; 2. 使用 show table status 作用: 可以查看视图的基本信息 语法: SHOW TABLE STATUS LIKE '视图名'; ----&gt; 注意like 引号 例如: show table status like 'stu_class' \\G; &gt; 3. 使用 show create view 作用: 不仅可以查看创建视图时的定义语句，还可以查看视图的字符编码 语法: SHOW CREATE VIEW 视图名; 例如: show create view stu_class \\G; &gt; 7.2.5 修改视图 &gt; 1. 使用 create or replace view 语句修改视图; 语法 : create or replace view 视图名 as select 表中字段 from 表名 create or replace view view_stu as select * from student; &gt; 2. 使用 alter 语句修改视图; 语法 : alter view 视图名 as select 表中字段 from 表名 alter view view_stu as select chinese from student; &gt; 7.2.6 更新视图 1. 使用update 语句更新视图 update view_stu set chinese=100; 2. 使用insert 语句更新视图 insert into student values(4,'Lily',100,100); 3. 使用delete语句更新视图 delete from view_stu2 where math=10; 7.2.7 删除视图 视图不在需要时,可以将其删除,删除视图只会删除视图的定义,不会删除数据. 删除一个或多个视图可以使用dorp view语句, 删除视图的基本语法格式如下所示: drop view [if exists] view_name [,view_name1] ... [restrict|cascade] view_name 是指要删除的视图的名称,视图名称可以添加多个,各个名称用逗号隔开,删除视图必须有root权限 例如: 删除view_stu2视图 drop view if exists view_stu2; 8.1 数据备份与还原 8.1.1 数据的备份 通过MySQL的mysqldump命令实现数据的备份 1. 备份单个数据库 mysqldump 命令备份数据库的语法格式如下 : mysqldump -u username -p password dbname [tbname] [tbname2...] &gt; filename.sql 上述语法格式中, -u后面的参数username 表示用户名, -p 后面的参数 password表示登录密码, dbname 表示需要备份的数据库的名称, tbname表示数据库中的表名, 可以指定一个表或多个表, 多个表之间用空格隔开, 如果不指定则备份整个数据库, filename.sql 表示备份文件的名称, 文件名前可以加上绝对路径 注意: 在使用mysqldump命令备份数据库时, 直接在dos命令行窗口中执行该命令即可, 不需要登录到mysql数据库 例如: 例如: 创建一个名称为chapter08的数据库, 并在数据库中创建表student, 插入相应数据 mysql&gt; create database chapter08 mysql&gt; use chapter08 Database changed mysql&gt; create table student( -&gt; id int primary key auto_increment, -&gt; name varchar(20), -&gt; age int -&gt; ); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into student(name,age) values -&gt; ('Tom',20), -&gt; ('Jack',16), -&gt; ('Lucy',18); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from student; +----+------+------+ | id | name | age | +----+------+------+ | 1 | Tom | 20 | | 2 | Jack | 16 | | 3 | Lucy | 18 | +----+------+------+ 3 rows in set (0.00 sec) 首先在C盘创建一个名为backupdb的 文件夹用来存备份好的文件夹, 然后重新开启一个dos命令行窗口( 不需要登录到MySQL数据库), 使用mysqldump命令登录备份chapter08 语法: C:\\Users\\ASUS&gt;mysqldump -u root -p chapter08 &gt; C:/backupdb/chapter08.sql Enter password: **** 查看备份: -- MySQL dump 10.13 Distrib 5.5.28, for Win32 (x86) -- -- Host: localhost Database: chapter08 -- ------------------------------------------------------ -- Server version 5.5.28 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!40101 SET NAMES utf8 */; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */; /*!40103 SET TIME_ZONE='+00:00' */; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; -- -- Table structure for table `student` -- DROP TABLE IF EXISTS `student`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `student` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `student` -- LOCK TABLES `student` WRITE; /*!40000 ALTER TABLE `student` DISABLE KEYS */; INSERT INTO `student` VALUES (1,'Tom',20),(2,'Jack',16),(3,'Lucy',18); /*!40000 ALTER TABLE `student` ENABLE KEYS */; UNLOCK TABLES; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; -- Dump completed on 2020-12-16 8:30:50 2. 备份多个数据库 mysqldump –u username –p password -–database dbname1 [dbname2 dbname3…] &gt;filename.sql 3. 备份所以数据库 mysqldump –uusername –ppassword -–all-databases&gt;filename.sql 8.1.2 数据的还原 语法: mysql –uusername –ppassword [dbname] &lt;filename.sql 1. 删除数据库 mysql&gt; drop database chapter08; 2. 创建数据库 mysql&gt; create database chapter08; Query OK, 1 row affected (0.01 sec) 3. 还原数据库 C:\\Users\\ASUS&gt;mysql -u root -p chapter08 &lt; C:/backupdb/chapter08-1.sql Enter password: **** 4. 查看数据 mysql&gt; use chapter08 Database changed mysql&gt; select * from student; +----+------+------+ | id | name | age | +----+------+------+ | 1 | Tom | 20 | | 2 | Jack | 16 | | 3 | Lucy | 18 | +----+------+------+ 3 rows in set (0.00 sec) 8.2 用户管理 8.2.1 user表 在安装数据库的时候会自动安装一个名为mysql的数据库, 该数据库中的表都是权限表, 如user, db, host ,table_priv 其中user表是最重要的一个权限表, 它记录了允许链接到服务器的账号信息以及一些全局级的权限信息, 通过操作表就可以对这些信息进行修改 mysql&gt; use mysql mysql&gt; desc user; +------------------------+-----------------------------------+------+-----+---------+-------+ | Field 字段名 | Type 数据类型 | Null | Key | Default | Extra | +------------------------+-----------------------------------+------+-----+---------+-------+ | Host | char(60) | NO | PRI | | | | User | char(16) | NO | PRI | | | | Password | char(41) | NO | | | | | Select_priv | enum('N','Y') | NO | | N | | | Insert_priv | enum('N','Y') | NO | | N | | | Update_priv | enum('N','Y') | NO | | N | | | Delete_priv | enum('N','Y') | NO | | N | | | Create_priv | enum('N','Y') | NO | | N | | | Drop_priv | enum('N','Y') | NO | | N | | | Reload_priv | enum('N','Y') | NO | | N | | | Shutdown_priv | enum('N','Y') | NO | | N | | | Process_priv | enum('N','Y') | NO | | N | | | File_priv | enum('N','Y') | NO | | N | | | Grant_priv | enum('N','Y') | NO | | N | | | References_priv | enum('N','Y') | NO | | N | | | Index_priv | enum('N','Y') | NO | | N | | | Alter_priv | enum('N','Y') | NO | | N | | | Show_db_priv | enum('N','Y') | NO | | N | | | Super_priv | enum('N','Y') | NO | | N | | | Create_tmp_table_priv | enum('N','Y') | NO | | N | | | Lock_tables_priv | enum('N','Y') | NO | | N | | | Execute_priv | enum('N','Y') | NO | | N | | | Repl_slave_priv | enum('N','Y') | NO | | N | | | Repl_client_priv | enum('N','Y') | NO | | N | | | Create_view_priv | enum('N','Y') | NO | | N | | | Show_view_priv | enum('N','Y') | NO | | N | | | Create_routine_priv | enum('N','Y') | NO | | N | | | Alter_routine_priv | enum('N','Y') | NO | | N | | | Create_user_priv | enum('N','Y') | NO | | N | | | Event_priv | enum('N','Y') | NO | | N | | | Trigger_priv | enum('N','Y') | NO | | N | | | Create_tablespace_priv | enum('N','Y') | NO | | N | | | ssl_type | enum('','ANY','X509','SPECIFIED') | NO | | | | | ssl_cipher | blob | NO | | NULL | | | x509_issuer | blob | NO | | NULL | | | x509_subject | blob | NO | | NULL | | | max_questions | int(11) unsigned | NO | | 0 | | | max_updates | int(11) unsigned | NO | | 0 | | | max_connections | int(11) unsigned | NO | | 0 | | | max_user_connections | int(11) unsigned | NO | | 0 | | | plugin | char(64) | YES | | | | | authentication_string | text | YES | | NULL | | +------------------------+-----------------------------------+------+-----+---------+------- 1. 用户列 用户列包括Host、User、Password,分别代表主机名、用户名和密码 其中Host和User列为user表的联合主键 当修改密码时，只需要修改,user表中Password字段的值即可 2. 权限列 user表的权限列包括Select_priv、Insert_priv、Update_priv等以priv结尾的字段，这些字段决定了用户的权限，其中包括查询权限、修改权限、关闭服务等权限。 3.安全列 user表的安全列用于管理用户的安全信息，其中包括6个字段，具体如下： ssl_type和ssl_cipher：用于加密 x509_issuer和x509_subject标准：可以用来标识用户 plugin和authentication_string：用于存储与授权相关的插件 4. 资源控制列 资源控制列是用于限制用户使用的资源，包括4个字段，具体如下： max_questions：每小时允许用户执行查询操作的次数 max_updates：每小时允许用户执行更新操作的次数 max_connections：每小时允许用户建立连接的次数 max_user_connections：允许单个用户同时建立连接的次数 8.2.2 创建普通用户 1. 使用 grant 语句创建用户 GRANT privileges ON database.table TO 'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname [IDENTIFIED BY [PASSWORD]'password']] … privileges 参数表示该用户具有的权限信息, database.table 表示新用户的权限范围表, 可以在指定的数据库, 表上使用自己的权限, username参数是新用户的名称, hostname参数是主机名, password参数是新用户的密码 例如: 使用grant 语句创建一个新用户, 用户名是user1, 密码是 123, 并授予该用户对chapter08.student 表具有查询权限 grant select on chapter08.student to 'user1'@'localhost' identified by '123'; mysql&gt; select host,user,password from user; +-----------+-------+-------------------------------------------+ | host | user | password | +-----------+-------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | localhost | user1 | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | +-----------+-------+-------------------------------------------+ 3 rows in set (0.00 sec) 2. 使用 create user 语句创建用户 CREATE USER 'username'@'hostname'[IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname'[IDENTIFIED BY [PASSWORD]'password']]… username参数是新用户的名称, hostname参数是主机名,identified by关键字用于设置用户的密码, password 表示用户的密码, [PASSWORD] 关键字表示使用哈希值设置的密码, 该参数是可选的, 如果密码是一个普通的字符串, 就不需要使用PASSWORD 关键字 例如: 使用create user语句创建一个新用户, 用户名为user2, 密码是123, create user语法如下: create user 'user2'@'localhost' identified by '123'; 3. 使用 insert 语句创建用户 INSERT INTO mysql.user(Host,User,Password,ssl_cipher、x509_issuer、x509_subject) VALUES('hostname','username',PASSWORD('password'),'','',''); 上述语法格式中, mysql.user表示操作的表, Host,User,Password,ssl_cipher、x509_issuer、x509_subject 为相应字段 PASSWORD( ) 是一个加密函数, 用于给密码加密 注意: 使用insert添加用户时, 通常只需要添加host, user和password这三个字段即可, 其他字段取默认值,但由于 Host,User,Password,ssl_cipher、x509_issuer、x509_subject 字段是没有默认值的, 因此insert语句创建用户时, 还需要为这几个字段设置初始值 例如: 使用insert 语句直接在mysql.user表中创建一个新用户, 用户名为user3, 密码为123 ,insert语句如下: insert into mysql.user(Host,User,Password,scl_cipher,x509_issuer,x509_subject) values('localhost','user3',password('123'),'',''); 注意: insert语句没有刷新权限表的功能, 因此,user3用户暂时不能使用,为了让当前用户生效, 还需要手动刷新当前的权限表或重新启动mysql服务, 刷新权限表的语句如下: flush privileges; 8.2.3 删除普通用户 1. 使用drop user 语句删除用户 drop user语句与drop database 语句有些相似, 如果删除某个用户, 只需在 drop user 后面指定要删除的用户信息即可 语法: drop user 'username'@'hostname'[,'username'@'hostname']; username 表示要删除的用户, hostname表示主机名, drop user语句可以同时删除一个或多个用户, 多个用户之间可以使用逗号隔开 注意: 使用drop user语句来删除用户时, 必须拥有drop user 权限 使用drop user语句删除用户 user1 drop user 'user'@'localhost'; 2. 使用 delete 语句删除用户 delete语句不仅可以删除普通表中的数据, 还可以删除 user表中的数据, 使用该语句删除 user表中的数据时, 只需要指定表名为mysql.user, 以及要删除的用户信息即可, 同样的, 在使用delete语句时必须拥有对mysql.user表的delete权限 语法格式如下: delete from mysql.user where host='hostname' and user='username'; 上述语法格式中, mysql.user 参数指定要操作的表, where 指定条件语句, host和user 都是mysql.user 表的字段, 这两个字段可以确定唯一的一条记录 例如: 使用delete语句删除用户 user2 delete from mysql.user where host='localhost' and user='user2'; 注意: 由于直接对user表进行操作, 执行完命令后需要使用'flush privileges' 语句重新加载用户权限 8.2.4 修改用户密码 1. 修改 root用户密码 一. 通过mysqladmin命令修改root用户的密码 mysqladmin命令通常用于执行一些管理性工作 语法格式如下: mysqladmin -u username [-h hostname] -p password new_password; username为要修改的用户名, 这里指的是root用户, 参数 -h 用于指定对应的主机, 可以省略不写, 默认为 localhost -p 后面的password为关键字, 而不是修改后的密码, new_password 为新设置的密码 注意: 在使用mysqladmin命令修改root用户密码时, 需要在 C: \\document and setting\\administrator&gt;目录下进行修改 例如: 在命令行窗口中使用mysqladmin命令, 将root用户的密码修改为mypwd1,sql语句如下: mysqladmin -u root -p password mypwd1 二. 通过update语句修改root用户的密码 由于所以的用户信息都存放在mysql.user表中, 因此,只有root用户登录到MySQL服务器, 使用update语句就可以直接修改自己的密码 语法格式如下 update mysql.user set password=password('mypwd2') where user='root' and host='localhost'; 上述语法执行成功后, 还需要使用 flush privileges 重新加载权限表, 然后就可以使用新密码登录 mysql数据库 结果如下 : 三. 使用set 语句修改root用户的密码 root用户登录到mysql数据库后, 还可以通过set语句修改root用户的密码 set语句修改密码的语法格式如下: set password=password('new_password'); 注意: 由于set语句没有对密码加密的功能, 因此, 新密码必须使用password() 函数加密, 并且新密码需要使用引号括起 例如: root用户登录到mysql数据库, 使用set 语句将root用户的密码修改为mypwd3, set语句如下: set password=password('mypwd3'); 2. root 用户修改普通用户的密码 1.使用grant语句修改普通用户密码 grant语句的作用比较多, 不仅可以创建用户授权, 还可以修改用户的密码, 通常情况下, 为了不影响当前账户的权限, 可以使用grant usage语句修改指定的账户的密码 grant语句修改密码语法格式如下: grant usage on * . * to 'username'@'localhost' identified by [password] 'new_password'; 2.使用update语句修改普通用户的密码 root用户具有操作数据库的所有权限, 因此, 它不仅可以使用update语句修改自己的密码, 还可以使用update语句修改普通用户的密码 update的语法格式为与root修改用户密码的语法格式相同 update mysql.user set password=password('new_password') where user='username' and host='hostname'; 注意: 通过上述语句修改完普通用户的密码后, 还需要使用flush privileges语句重新加载权限表 3.使用set语句修改普通用户的密码 set 不仅可以修改root用户的密码, 而且还可以修改普通用户密码, 在修改普通用户密码时, 还需要增加一个for子句, 指定要修改哪一个用户即可 set语句修改密码的语法格式如下 set password for 'username'@'hostname'=password('new_password'); 3. 普通用户修改密码 普通用户也可以修改自己的密码, 这样普通用户就不需要每次修改密码时都通知管理员, 普通用户登录到MySQL服务器后, 可以通过set语句来设置自己的密码 set语句的基本格式如下: set password=password('new_password'); set语句修改普通用户密码时, 和修改root用户是一样的, 都需要使用password() 函数进行加密 8.3 权限管理 8.3.1 MySQL的权限 Mysql中的权限信息被储存在mysql 数据库的 user,db,host,table_priv,column_priv和procs_priv表中, 当MySQL启动时会自动加载这些权限信息, 并将这些权限信息读取到内存中 权限解释: 1. create和drop的权限, 可以创建数据库,表,索引,或者删除已有的数据库, 表, 索引 2. insert, delete,update,select 权限,可以对数据库中的表进行增删改查操作 3. index权限,可以创建或删除索引, 适用于所以的表 4. alter权限.可以用于修改表的结构或重命名表 5. grant权限, 允许为其他用户授权, 可用于数据库和表 6. file权限, 被赋予该权限的用户能读写MySQL服务器上的任何文件 8.3.2 授予权限 我们之所以可以对数据进行增删改查的操作，是因为数据库中的用户拥有不同的权限，合理的授权可以保证数据库的安全 MySQL中的GRANT语句可以为用户授权，语法格式如下: GRANT privileges [(columns)][,privileges[(columns)]] ON database.table TO 'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password']] … [WITH with_option [with_option]…] privileges：表示权限类型。 columns：参数表示权限作用于某一列，该参数可以省略不写，此时权限作用于整个表，username：表示用户名。 hostname表示主机名。 IDENTIFIED BY：参数为用户设置密码。 PASSWORD参数为关键字. password为用户的新密码。 WITH关键字后面可以带有多个参数with_option，这个参数有五个取值 具体如下: GRANT OPTION：将自己的权限授予其他用户MAX_QUERIES_PER_HOUR count：设置每小时最多可以执行多少次（count）查询。 MAX_UPDATES_PER_HOUR count：设置每小时最多可以执行多少次更新。 MAX_CONNECTIONS_PER_HOUR count：设置每小时最大的连接数量。 MAX_USER_CONNECTIONS：设置每个用户最多可以同时建立连接的数量。 8.3.3 查看权限 虽然使用SELECT语句可以查询user表中的权限信息，但是该语句需要指定用户和查询的权限，比较麻烦，MySQL还提供了一个查看权限的简单语句-SHOW GRANTS语句 SHOW GRANTS的语法格式如下: SHOW GRANTS FOR 'username'@'hostname'; 语法格式相对简单, 只需要指定查询的用户名和主机名即可 例1: 使用show grants语句查询root用户的权限信息 show grants for 'root'@'hostname'; 例2: 使用show grants语句查询user4 用户的权限信息 show grants for 'user4'@'hostname'; 8.3.4 收回权限 为了保证数据库的安全性，需要将用户不必要的权限收回，收回用户权限使用REVOKE语句 收回用户指定权限, 语法格式如下所示 : REVOKE privileges [columns][,privileges[(columns)]] ON database.table FROM 'username'@'hostname'[,'username'@'hostname'] … revoke语法格式中的参数与grant语句中的参数意思相同, privileges参数表示收回的权限,columns表示权限作用于哪列上, 如果不指定该参数表示作用于整个表 使用revoke语句收回user4用户的insert权限, revoke语句如下: revoke insert on * . * from 'user'@'localhost'; 如果权限比较多可以使用收回所以权限的功能 收回用户全部权限, 语法格式如下所示 : REVOKE ALL PRIVILEGES,GRANT OPTION FROM 'username'@'hostname' [,'username'@'hostname'] … 使用revoke语句收回user4用户的insert权限, revoke语句如下: revoke all privileges,grant option from 'user4'@'localhost'; ","tags":[{"index":-1,"name":"MySQL","slug":"mfzycuj_f","used":true,"link":"https://aoianz.github.io/tag/mfzycuj_f/"}],"title":"朝花夕拾 Mysql","feature":"https://aoianz.github.io/post-images/mysql.jpg","link":"https://aoianz.github.io/post/mysql/","stats":{"text":"80 min read","time":4757000,"words":18778,"minutes":80},"date":"2021-11-13 22:18:18","dateFormat":"2021-11-13"},{"content":" 软件设计风格: 本软件采用明亮的黄色作为软件主题色 明亮快活，洋溢活力，注入了太阳能量的暖黄色调 ","tags":[{"name":"Android","slug":"wFZpTJOOV","used":true,"link":"https://aoianz.github.io/tag/wFZpTJOOV/"}],"title":"Android开发小作品：一本记账.app","feature":"","link":"https://aoianz.github.io/post/qWwCxcaUG/","stats":{"text":"1 min read","time":8000,"words":43,"minutes":1},"date":"2021-10-18 08:59:07","dateFormat":"2021-10-18"},{"content":"安卓Toast获取输入框文本 欢迎扫码关注微信公众号&quot;野心与家&quot; 在开发过程中如果我们想用Toast获取EditText的值 关键方法是使用getText()获取,再将获取到的值打印在Toast上 例如在一个界面上,想要用Toast提示用户设置的密码 效果如下: 实现代码部分如下 EditText etName = (EditText) findViewById(R.id.EditT); String inputPwd=etName.getText().toString(); Toast.makeText(MainActivity2.this,&quot;密码设置成功!\\n您输入的密码为:&quot;+inputPwd,Toast.LENGTH_LONG).show(); //方法二:直接在Toast使用getText(),此方法就不必写String inputPwd=etName.getText().toString(); //Toast.makeText(MainActivity2.this,&quot;密码设置成功！\\n您输入的密码为：&quot;+etName.getText().toString(),Toast.LENGTH_LONG).show(); 注意此方法无法限制用户输入的文本类型例如空格 使用android:digits可以限制用户输入的字符类型 例如: android:digits=&quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot; 在活动建立一个EditText对象以从EditText中查看检索数据，并使用findViewById()方法从布局找到EditText EditText etName = (EditText)findViewById(R.id.editText1); 后可以使用getText()方法来检索与该视图关联的文本信息，它须要被转换为字符串 strName = etName.getText().toString(); ","tags":[],"title":"安卓Toast获取输入框文本","feature":"","link":"https://aoianz.github.io/post/tZappBHgq/","stats":{"text":"2 min read","time":72000,"words":302,"minutes":2},"date":"2021-05-24 14:05:20","dateFormat":"2021-05-24"},{"content":"安卓动态添加隐藏碎片简单用法 欢迎扫码关注微信公众号&quot;野心与家&quot; 首先新建两个碎片: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.myFragment&quot;&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/fragment1&quot; /&gt; &lt;/FrameLayout&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.myFragment2&quot;&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/fragment2&quot; /&gt; &lt;/FrameLayout&gt; 在主活动添加两个按钮: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity4&quot;&gt; &lt;!-- 静态添加Fragment,在布局文件中以控件的形式添加--&gt; &lt;!-- 注意:id属性必须设置,name属性必须设置,需要使用完整的包名--&gt; &lt;Button android:id=&quot;@+id/btn_add&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;152dp&quot; android:layout_marginTop=&quot;800dp&quot; android:layout_marginEnd=&quot;152dp&quot; android:layout_marginBottom=&quot;100dp&quot; android:text=&quot;添加碎片&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/btn_hide&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/fragment&quot; app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_hide&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;152dp&quot; android:layout_marginEnd=&quot;152dp&quot; android:layout_marginBottom=&quot;50dp&quot; android:text=&quot;隐藏碎片&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/btn_add&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.816&quot; /&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/constraint&quot; android:layout_width=&quot;470dp&quot; android:layout_height=&quot;259dp&quot; android:layout_marginStart=&quot;480dp&quot; android:layout_marginTop=&quot;56dp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 在主活动程序按钮注册一个点击事件 Button btn_add = (Button) findViewById(R.id.btn_add); Button btn_hide = (Button) findViewById(R.id.btn_hide); btn_add.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // btn_add.setText(&quot;我单击了该按钮&quot;); myFragment2 fragment2 =new myFragment2();//创建一个 FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction();//开启一个事务 // transaction.add(R.id.constraint,fragment2); transaction.replace(R.id.constraint,fragment2);//在一个容器中替换一个碎片,如果碎片不存在则新建一个碎片,如果碎片存在则替换(建议使用) transaction.commit(); } }); btn_hide.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // btn_hide.setText(&quot;我单击了该按钮&quot;); FragmentManager fragmentManager = getSupportFragmentManager(); myFragment fragment1 = (myFragment) fragmentManager.findFragmentById(R.id.fragment);//通过id属性引用布局文件的存在的碎片 FragmentTransaction transaction1 = fragmentManager.beginTransaction(); transaction1.hide(fragment1);//隐藏 transaction1.commit(); } }); 总结: 在上述代码中调用getSupportFragmentManager();方法得到FragmentManager 通过调用beginTransaction()方法开启一个事物 使用replace()向容器内动态添加或替换碎片 使用hide()向隐藏碎片 ","tags":[],"title":"安卓动态添加隐藏碎片简单用法","feature":"","link":"https://aoianz.github.io/post/HWV1nuhNt/","stats":{"text":"5 min read","time":248000,"words":776,"minutes":5},"date":"2021-05-20 14:07:57","dateFormat":"2021-05-20"},{"content":"安卓--实现获取控件数据 欢迎扫码关注微信公众号&quot;野心与家&quot; 运行效果图 : 完整代码如下 : public class MainActivity8 extends AppCompatActivity implements View.OnClickListener { private Button btn_submit; private Button btn_exit; private String user; private RadioGroup rg_sex; private RadioButton radioButton; private CheckBox checkBox1, checkBox2, checkBox3; private List&lt;CheckBox&gt; checkBoxList = new ArrayList&lt;CheckBox&gt;(); private StringBuffer sb; private Spinner textSpinner; private String getContent; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); btn_submit=(Button) findViewById(R.id.btn_submit); btn_exit=(Button) findViewById(R.id.btn_exit); btn_submit.setOnClickListener(this);//应用当前接口作为监听器 btn_exit.setOnClickListener(this); rg_sex=(RadioGroup) findViewById(R.id.rg_sex); checkBox1 = (CheckBox) findViewById(R.id.checkbox1); checkBox2 = (CheckBox) findViewById(R.id.checkbox2); checkBox3 = (CheckBox) findViewById(R.id.checkbox3); checkBoxList.add(checkBox1); checkBoxList.add(checkBox2); checkBoxList.add(checkBox3); textSpinner = (Spinner) findViewById(R.id.spinner); } @Override public void onClick(View view) { switch (view.getId()){ case R.id.btn_submit: //1.获取RadioGroup当中选中的RadioButton中的内容 radioButton=(RadioButton) findViewById(rg_sex.getCheckedRadioButtonId()); user=&quot;性 别:&quot;+radioButton.getText().toString(); //2.获取CheckBox中的内容 StringBuffer sb = new StringBuffer(); for (CheckBox checkbox: checkBoxList){ if (checkbox.isChecked()){ sb.append(checkbox.getText().toString()+&quot; &quot;); } } //3.获取Spinner中的内容 String getContent = &quot;学 历:&quot;+textSpinner.getSelectedItem().toString(); Toast.makeText(MainActivity8.this, &quot;您输入的内容是:\\r\\n&quot;+user+&quot;\\r\\n&quot;+&quot;爱 好:&quot;+sb+&quot;\\r\\n&quot;+getContent, Toast.LENGTH_LONG).show(); break; case R.id.btn_exit: // Toast.makeText(MainActivity8.this, &quot;我单机了退出按钮&quot;, Toast.LENGTH_SHORT).show(); finish(); } } } xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;8dp&quot; tools:context=&quot;.MainActivity8&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;性 别:&quot;/&gt; &lt;RadioGroup android:id=&quot;@+id/rg_sex&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:checkedButton=&quot;@id/rb_girl&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:id=&quot;@+id/rb_boy&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;男&quot;/&gt; &lt;RadioButton android:id=&quot;@+id/rb_girl&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;女&quot;/&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;爱 好:&quot;/&gt; &lt;!--多选框可以使用checked属性设置默认选中,但不推荐用于单选按钮--&gt; &lt;CheckBox android:id=&quot;@+id/checkbox1&quot; android:checked=&quot;true&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;音乐&quot;/&gt; &lt;CheckBox android:id=&quot;@+id/checkbox2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;美术&quot;/&gt; &lt;CheckBox android:id=&quot;@+id/checkbox3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;体育&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;学 历:&quot;/&gt; &lt;Spinner android:id=&quot;@+id/spinner&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:entries=&quot;@array/myarray&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/btn_submit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginRight=&quot;16dp&quot; android:text=&quot;提交&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_exit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;退出&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; ","tags":[],"title":"安卓--实现获取控件数据","feature":"","link":"https://aoianz.github.io/post/CkffoeZLI/","stats":{"text":"5 min read","time":282000,"words":816,"minutes":5},"date":"2021-05-20 14:06:27","dateFormat":"2021-05-20"},{"content":"朝花夕拾---jQuery笔记 1.jQuery基本使用 1. jQuery对象和DOM对象 1.用原生JS获取来的对象就是DOM对象 2.jQuery方法获取的元索就是jQuery对象。 3.jQuery对象本质是:利用$对DOM对象包装后产生的对象(伪数组形式存储)。 &lt;style&gt; div { width: 100px; height: 100px; background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; //1.DOM对象:用原生js获取过来的就是DOM对象 var myDiv = document.querySelector('div');//myDiv就是DOM对象 //2.jQuery对象: 用jQuery获取过来的就是JQuery对象 $('div'); // $('div');是一个JQuery对象 console.dir($('div')); //3.jQuery对象只能使用jquery方法,DOM对象则使用原生的JavaScript属性和 myDiv.style.display = 'none';//调用原生隐藏 // $('div').style.display = 'none';这个$('div')是一个jquery的像不能使用原生js的属性和方法 &lt;/script&gt; &lt;/body&gt; 2.jQuery对象和DOM对象相互转化 &lt;body&gt; &lt;video src=&quot;mov.mp4&quot;&gt;&lt;/video&gt; &lt;script&gt; //1. 直接获取视频,得到的就是jquery对象 $('video'); //2. 用原生js获取为DOM对象 var myvideo = document.querySelector('video'); // $(myvideo).play; jQuery里面没有play这个方法 // myvideo.play(); //2.转化为jQuery对象 $('video')[0].play(); $('video').get(0).play() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2. jQuery选择器 2.1 jQuery 基础选择器 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 $(“选择器”) // 里面选择器直接写 CSS 选择器即可，但是要加引号 名称 用法 描述 ID选择器 $(&quot;#id&quot;) 获取指定ID的元素 通配符选择器 $(&quot;*&quot;) 匹配所有元素 类选择器 $(&quot;.class&quot;) 获取同一类class的元素 标签/元素选择器 $(&quot;div&quot;) 获取同一类标签的所有元素 并集选择器 $(&quot;div,p,li&quot;) 选取多个元素 交集选择器 $(&quot;li.current&quot;) 交集元素 ID选择器: $(&quot;#byId&quot;).css(&quot;background&quot;,&quot;pink&quot;); 类选择器: $(&quot;.byClass&quot;).css(&quot;background&quot;,&quot;red&quot;); 标签/元素选择器: $(&quot;p&quot;).css(&quot;font-size&quot;,&quot;10px&quot;); 通配符选择器: $(&quot;*&quot;).css(&quot;background&quot;,&quot;yellow&quot;); 并集选择器: $(&quot;.byClass,#byId&quot;).css(&quot;background&quot;,&quot;pink&quot;); 2.2 jQuery 层级选择器 2.3 隐式迭代（重要） 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作,方便我们调用。 &lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;ul&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //1.获取四个div元素 console.log($(&quot;div&quot;)); //2.给四个div设置背景颜色为粉色,jQuery对象不能使用style $(&quot;div&quot;).css(&quot;background&quot;,&quot;pink&quot;); //3.隐式迭代就是匹配的所有元素内部进行遍历循环，给每一个元素添加css这个方法 $(&quot;ul li&quot;).css(&quot;color&quot;,&quot;red&quot;); &lt;/script&gt; &lt;/body&gt; 2.4筛选/过滤选择器 语法 用法 描述 :first $(&quot;li:first&quot;) 获取第一个li元素 :last $(&quot;li:last&quot;) 获取最后一个li元素 :eq(index) $(&quot;li:eq(2)&quot;) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(&quot;li:odd&quot;) 获取到的li元素中，选择索引号为奇数的元素 :even $(&quot;li:even&quot;) 获取到的li元素中，选择索引号为偶数的元素 2.5jQuery筛选方法(重点) 语法 用法 说明 parent $(&quot;li&quot;) . parent(); 查找父级 children(selector) $(&quot;ul&quot;).children(&quot;li&quot;) 相当于$(&quot;ul&gt;li&quot;),最近一级(亲儿子) find(selector) $(&quot;ul&quot;). find(&quot;li&quot;); 相当于$(&quot;ul li&quot;),后代选择器 siblings(selector) $(&quot;. first&quot;). siblings(&quot;li&quot;); 查找兄弟节点，不包括自己本身 nextAll([expr]) $(&quot;. first&quot;). nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(&quot;. last&quot;). prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(&quot;.div&quot;). hasClass(&quot;protected&quot;) 检查当前的元素是否含有某个特定的类,如果有，则返回true eq(index) $(&quot;li&quot;). eq(2); 相当于$(&quot;li:eq(2)&quot;), index从0开始 重点记住： parent() children() find() siblings() eq() 2.6 jQuery 里面的排他思想 想要做多选一效果 $(this).css(“color”,”red”); $(this).siblings().css(“color”,””); 例如: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;08.排他思想.html&lt;/title&gt; &lt;script src=&quot;../js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;button&gt;按钮6&lt;/button&gt; &lt;button&gt;按钮7&lt;/button&gt; &lt;script&gt; $(function(){ //1. 隐式迭代 给所有按钮都绑定点击事件 $(&quot;button&quot;).click(function(){ //2. 当前的元素变换背景颜色 $(this).css(&quot;background&quot;,&quot;pink&quot;); //3. 其余兄弟去掉背景颜色 隐式迭代 // $(this).siblings(&quot;button&quot;).css(&quot;background&quot;,&quot;&quot;); // $(this).siblings().css(&quot;background&quot;,&quot;&quot;); // 因为此处siblings()只有一个button所以可以省略 //4. 链式编程 $(this).css(&quot;background&quot;,&quot;pink&quot;).siblings().css(&quot;background&quot;,&quot;&quot;); }); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.7 链式编程 链式编程是为了节省代码量，看起来更优雅。 $(this).css('color', 'red').sibling().css('color', ''); 例如: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;script&gt; $(function() { // 1. 隐式迭代 给所有的按钮都绑定了点击事件 $(&quot;button&quot;).click(function() { // 2. 让当前元素颜色变为红色 // $(this).css(&quot;color&quot;, &quot;red&quot;); // 3. 让其余的姐妹元素不变色 // $(this).siblings().css(&quot;color&quot;, &quot;&quot;); // 链式编程 $(this).css(&quot;color&quot;, &quot;red&quot;).siblings().css(&quot;color&quot;, &quot;&quot;); }); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.jQuery 样式操作 3.1 操作 css 方法 jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。 1.参数只写属性名，则是返回属性值 $(this).css(&quot;color&quot;); 2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 $(this).css(''color'', ''red''); 3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号 $(this).css( { &quot;color&quot;:&quot;white&quot;, &quot;font-size&quot;:&quot;20px&quot; } ); 例如: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 操作样式之css方法 $(function() { console.log($(&quot;div&quot;).css(&quot;width&quot;)); // $(&quot;div&quot;).css(&quot;width&quot;, &quot;300px&quot;); // $(&quot;div&quot;).css(&quot;width&quot;, 300); // $(&quot;div&quot;).css(height, &quot;300px&quot;); 属性名一定要加引号 $(&quot;div&quot;).css({ width: 400, height: 400, backgroundColor: &quot;red&quot; // 如果是复合属性则必须采取驼峰命名法，如果值不是数字，则需要加引号 }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.2 设置类样式方法 作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;); 2.移动类 $(&quot;div&quot;).removeClass(&quot;current&quot;); 3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;); 例如: &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 150px; height: 150px; background-color: pink; margin: 100px auto; transition: all 0.5s; } .current { background-color: red; transform: rotate(360deg); } &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;current&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 添加类 addClass() // $(&quot;div&quot;).click(function() { // // $(this).addClass(&quot;current&quot;); // }); // 2. 删除类 removeClass() // $(&quot;div&quot;).click(function() { // $(this).removeClass(&quot;current&quot;); // }); // 3. 切换类 toggleClass() $(&quot;div&quot;).click(function() { $(this).toggleClass(&quot;current&quot;); }); }) &lt;/script&gt; &lt;/body&gt; 3.3 类操作与className的区别 原生 JS 中 className 会覆盖元素原先里面的类名。 jQuery 里面类操作只是对指定类进行操作，不影响原先的类名 例如: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .one { width: 200px; height: 200px; background-color: pink; transition: all .3s; } .two { transform: rotate(720deg); } &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;one two&quot;&gt;&lt;/div&gt; &lt;script&gt; //原生js // var one = document.querySelector(&quot;.one&quot;); // one.className = &quot;two&quot;; // $(&quot;.one&quot;).addClass(&quot;two&quot;); 这个addClass相当于追加类名 不影响以前的类名 $(&quot;.one&quot;).removeClass(&quot;two&quot;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4. jQuery 效果 4.1 显示隐藏效果 4.1.1 显示语法规范 show([speed,[easing],[fn]]) 4.1.2 隐藏语法规范 hide([speed,[easing],[fn]]) 4.1.3 切换语法规范 toggle([speed,[easing],[fn]]) 4.1.4 参数含义 参数都可以省略， 无动画直接显示。 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 4.2 滑动效果 4.2.1 下滑效果语法规范 slideDown([speed,[easing],[fn]]) 4.2.2 下滑效果语法规范 slideUp([speed,[easing],[fn]]) 4.2.3 滑动切换效果语法规范 slideToggle([speed,[easing],[fn]]) 4.2.4 滑动效果参数 参数都可以省略。 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 4.3 事件切换 hover([over,]out) over:鼠标移到元素上要触发的函数（相当于mouseenter） out:鼠标移出元素要触发的函数（相当于mouseleave） 如果只写一个函数，则鼠标经过和离开都会触发它 4.4 动画队列及其停止排队方法 4.4.1 动画或效果队列 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行 4.4.2 停止排队 stop() (1）stop() 方法用于停止动画或效果。 (2) 注意： stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 4.5 淡入淡出效果 4.5.1 淡入效果语法规范 fadeIn([speed,[easing],[fn]]) 4.5.2 淡出效果语法规范 fadeOut([speed,[easing],[fn]]) 4.5.3 淡入淡出切换效果语法规范 1.参数都可以省略。 2.speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 3.easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 4.fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 4.5.4 渐进方式调整到指定的不透明度 fadeTo([[speed],opacity,[easing],[fn]]) 4.5.5 效果参数 1.opacity 透明度必须写，取值 0~1 之间。 2.speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。必须写 3.easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 4.fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 4.6 自定义动画animate 4.6.1 语法 animate(params,[speed],[easing],[fn]) 4.6.2 参数 1.params: 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采 取驼峰命名法 borderLeft。其余参数都可以省略。 2.speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 3.easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 4.fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 5.jQuery属性操作 5.1 设置或获取元素固有属性值prop() 所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 获取属性语法 prop(&quot;属性&quot;) 设置属性语法 prop(&quot;属性&quot;,&quot;属性值&quot;) 5.2 设置或获取元素自定义属性值 attr() 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 获取属性语法 attr(''属性'') // 类似原生 getAttribute() 设置属性语法 attr(''属性'', ''属性值'') // 类似原生 setAttribute() 5.3 数据缓存data() data() 方法可以在指定的元素上存取数据，并不会修改DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 附加数据语法 data(''name'',''value'') // 向被选元素附加数据 获取数据语法 date(''name'') // 向被选元素获取数据 同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型 6. jQuery 内容文本值 主要针对元素的内容还有表单的值操作。 1. 普通元素内容 html()（ 相当于原生inner HTML) html() // 获取元素的内容 html(''内容'') // 设置元素的内容 2. 普通元素文本内容 text() (相当与原生 innerText) text() // 获取元素的文本内容 text(''文本内容'') // 设置元素的文本内容 3. 表单的值 val()（ 相当于原生value) val() // 获取表单的值 val(''内容'') // 设置表单的值 7. jQuery 元素操作 主要是遍历、创建、添加、删除元素操作。 7.1 遍历元素 jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 $.each(object，function (index, element) { xxx; }) $.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象 2.里面的函数有2个参数： index 是每个元素的索引号; element 遍历内容 7.2 创建元素 语法: $(''&lt;li&gt;&lt;/li&gt;''); 动态的创建了一个 7.3 添加元素 1. 内部添加 element.append(''内容'') 把内容放入匹配元素内部最后面，类似原生 appendChild element.prepend(''内容'') 把内容放入匹配元素内部最前面。 2. 外部添加 element.after(''内容'') // 把内容放入目标元素后面 element.before(''内容'') // 把内容放入目标元素前面 ① 内部添加元素，生成之后，它们是父子关系 ② 外部添加元素，生成之后，他们是兄弟关系 7.4 删除元素 element.remove() // 删除匹配的元素（本身） element.empty() // 删除匹配的元素集合中所有的子节点 element.html('''') // 清空匹配的元素内容 ① remove 删除元素本身 ② empt() 和 html('''') 作用等价，都可以删除元素里面的内容，只不过 html 还可以设置内容 8.Query 尺寸、位置操作 8.1 jQuery尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值只算width / height innerWidth/innerHeight() 取得匹配元素宽度和高度值包含padding outWidth()/outerHeight() 取得匹配元素宽度和高度值包含padding、border outerWidth(true)/outerHeight(true) 取得匹配元素宽度和高度值包含padding、borde、 margin 以上参数为空，则是获取相应值，返回的是数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 8.2 jQuery 位置 位置主要有三个： offset()、position()、scrollTop()/scrollLeft() 1.offset() 设置或获取元素偏移 offset() 方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。 该方法有2个属性 left、top 。offset().top 用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({ top: 10, left: 30 }) 2.position() 获取元素偏移 position() 方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。 该方法有2个属性 left、top。position().top 用于获取距离定位父级顶部的距离，position().left 用于获取距离定 位父级左侧的距离。 该方法只能获取,不能设置偏移 3. scrollTop()/scrollLeft() 设置或获取元素被卷去的头部和左侧 scrollTop() 方法设置或返回被选元素被卷去的头部。 不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部 ","tags":[],"title":"朝花夕拾 jQuery笔记","feature":"","link":"https://aoianz.github.io/post/CnZyIsbWd/","stats":{"text":"21 min read","time":1212000,"words":4575,"minutes":21},"date":"2021-05-19 14:15:10","dateFormat":"2021-05-19"},{"content":"利用selenium自动化实现搜索框输入内容 欢迎扫码关注微信公众号&quot;野心与家&quot; 1.打开百度页面 2.获取当前页面的ur,并打印出来(driver.current url) 3.获取当前页面的title,并打印出来(driver.title) 4.百度&quot;selenium&quot; ,点击百度一下 5.判断页面中的“百度一下” 按钮是否正常显示，是则打印&quot;正常显示按钮” 6.获取文本框中的文本，并打印出来 7.清除百度文本框中内容 8.获取页面底部的信息:把百度设为主页关于百度About Baidu百度推广 9.关闭浏览器 运行结果如下: 实现代码如下: from selenium import webdriver from selenium.webdriver.common.keys import Keys import time driver=webdriver.Firefox() driver.get(&quot;https://www.baidu.com&quot;) # 获取url和title并打印 print(driver.current_url) print(driver.title) # 判断百度一下是否正常显示 flag=driver.find_element_by_id(&quot;su&quot;).is_displayed() if flag: print(&quot;正常显示按钮&quot;); else: print(&quot;显示异常&quot;); # 百度selenium,并点击百度一下 shuru=driver.find_element_by_id(&quot;kw&quot;) shuru.send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() # 获取文本框内容并打印 print(shuru.get_attribute(&quot;value&quot;)) # 清除百度文本框内容 time.sleep(2) shuru.clear() # 获取页面底部信息 xinxi=driver.find_element_by_class_name(&quot;s-bottom-layer-content&quot;) print(xinxi.get_attribute(&quot;textContent&quot;)) time.sleep(5) driver.quit() ","tags":[],"title":"利用selenium自动化实现搜索框输入内容","feature":"","link":"https://aoianz.github.io/post/aADdl8O_B/","stats":{"text":"2 min read","time":90000,"words":345,"minutes":2},"date":"2021-05-11 14:12:13","dateFormat":"2021-05-11"},{"content":"Selenium实战练习1_淘宝登录 欢迎扫码关注微信公众号&quot;野心与家&quot; 1.打开淘宝首页，点击“亲，请登录”,在打开的页面输入用户名和密码,点击登录按钮获取页面中信息进行判断。（此处可输入错误的密码获取提示信息作为实际结果） from selenium import webdriver from selenium.webdriver.common.keys import Keys import time driver=webdriver.Firefox() driver.get(&quot;https://www.taobao.com/&quot;) # 点击&quot;亲,请登录&quot; driver.find_element_by_link_text(&quot;亲，请登录&quot;).click() # 输入用户名和密码(避免淘宝验证,输入空值) driver.find_element_by_id(&quot;fm-login-id&quot;).send_keys(&quot; &quot;) driver.find_element_by_id(&quot;fm-login-password&quot;).send_keys(&quot; &quot;) # 点击登录按钮获取页面中的信息进行判断 # driver.find_element_by_class_name(&quot;fm-button fm-submit password-login&quot;).click() driver.find_element_by_xpath(&quot;/html/body/div/div[2]/div[3]/div/div/div/div[2]/div/form/div[4]/button&quot;).click() acl=driver.find_element_by_class_name(&quot;login-error-msg&quot;).text exp=&quot;请输入帐户名&quot; if acl==exp: print(&quot;登录失败&quot;) else: print(&quot;运行成功&quot;) time.sleep(10) driver.quit() 2.点击 cofirm.html页面中的按钮，获取提示框中的文本，并点击取消按钮，写出代码即可（无需运行）。 &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show_confirm() { var r=confirm(&quot;Press a button!&quot;); if (r==true) { alert(&quot;You pressed OK!&quot;); } else { alert(&quot;You pressed Cancel!&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; onclick=&quot;show_confirm()&quot; value=&quot;Show a confirm box&quot; /&gt; &lt;/body&gt; &lt;/html&gt; # 点击cofirm.html页面的按钮 driver.find_element_by_xpath(&quot;/html/body/input&quot;).click() alert = driver.switch_to.alert # 获取提示框文本 alert_text = alert.text print(alert_text) # 点击取消按钮 alert.dismiss() 3、点击 prompt.html页面中的按钮，向提示框中输入做自己的姓名，并点击确定按钮，写出代码即可（无需运行） &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function disp_prompt() { var name=prompt(&quot;请输入您的名字&quot;,&quot;Bill Gates&quot;) if (name!=null &amp;&amp; name!=&quot;&quot;) { document.write(&quot;你好，&quot; + name + &quot;！今天过得好吗？&quot;) } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; onclick=&quot;disp_prompt()&quot; value=&quot;显示一个提示框&quot; /&gt; &lt;/body&gt; &lt;/html&gt; driver.find_element_by_xpath(&quot;/html/body/input&quot;).click() alert = driver.switch_to.alert # 提示框中输入姓名 alert_send = alert.send_keys(&quot;赵志乾&quot;) # 点击确定按钮 alert.accept() ","tags":[],"title":"Selenium实战练习1_淘宝登录","feature":"","link":"https://aoianz.github.io/post/HYIIPTFcc/","stats":{"text":"3 min read","time":169000,"words":582,"minutes":3},"date":"2021-04-04 14:10:54","dateFormat":"2021-04-04"},{"content":"Android练习使用约束布局构建简单计算器效果 欢迎扫码关注微信公众号&quot;野心与家&quot; 效果如下: 技巧:每4个一组排列使用链式 (Chains) 具体步骤: 1.选中一组 组件 , 然后 右键 选择 Chains -&gt; Create Horizontal Chain , 即 创建了一个 水平方向的 Chains ( 链式约束 ) 2.创建链式后,选择上方Align按钮-进行水平方向上对齐 具体如下: 原代码如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_end=&quot;605dp&quot; /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=&quot;@+id/guideline3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_begin=&quot;553dp&quot; /&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;50dp&quot; android:text=&quot;0&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/guideline3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button6&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button6&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;.&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button5&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button7&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button5&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button5&quot; /&gt; &lt;Button android:id=&quot;@+id/button7&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;%&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button6&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button8&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button6&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button6&quot; /&gt; &lt;Button android:id=&quot;@+id/button8&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;=&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button7&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button7&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button7&quot; /&gt; &lt;Button android:id=&quot;@+id/button9&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;4dp&quot; android:text=&quot;1&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button5&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button10&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button11&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;3&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button10&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button12&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button10&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button10&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; /&gt; &lt;Button android:id=&quot;@+id/button12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;+&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button11&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button11&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button11&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; /&gt; &lt;Button android:id=&quot;@+id/button10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;2&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button9&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button11&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button9&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button9&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; /&gt; &lt;Button android:id=&quot;@+id/button13&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;4dp&quot; android:text=&quot;4&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button9&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button14&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button14&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;5&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button13&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button15&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button13&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button13&quot; /&gt; &lt;Button android:id=&quot;@+id/button15&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;6&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button14&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button16&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button14&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button14&quot; /&gt; &lt;Button android:id=&quot;@+id/button16&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;-&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button15&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button15&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button15&quot; /&gt; &lt;Button android:id=&quot;@+id/button17&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;4dp&quot; android:text=&quot;7&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button13&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button18&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button18&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;8&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button19&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button17&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button17&quot; /&gt; &lt;Button android:id=&quot;@+id/button19&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;9&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button18&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button20&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button18&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button18&quot; /&gt; &lt;Button android:id=&quot;@+id/button20&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;*&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button19&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button19&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button19&quot; /&gt; &lt;Button android:id=&quot;@+id/button21&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;4dp&quot; android:text=&quot;AC&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button17&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button22&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt; &lt;Button android:id=&quot;@+id/button22&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;DEL&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button21&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button23&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button21&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button21&quot; /&gt; &lt;Button android:id=&quot;@+id/button23&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;-/+&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button22&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/button24&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button22&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button22&quot; /&gt; &lt;Button android:id=&quot;@+id/button24&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;/&quot; android:textSize=&quot;24sp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/button23&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.5&quot; app:layout_constraintStart_toEndOf=&quot;@+id/button23&quot; app:layout_constraintTop_toTopOf=&quot;@+id/button23&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;66dp&quot; android:layout_height=&quot;121dp&quot; android:layout_marginTop=&quot;67dp&quot; android:layout_marginEnd=&quot;16dp&quot; android:text=&quot;0.&quot; android:textSize=&quot;80sp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; ","tags":[],"title":"Android练习使用约束布局构建简单计算器效果","feature":"","link":"https://aoianz.github.io/post/QgatnF3kx/","stats":{"text":"10 min read","time":540000,"words":1492,"minutes":10},"date":"2021-03-17 14:14:10","dateFormat":"2021-03-17"},{"content":"Selenium实战练习2_实现邮箱反向的注册功能 欢迎扫码关注微信公众号&quot;野心与家&quot; 要求: 实现代码: veydows_reg_emal_false_dict: from selenium import webdriver import time datainfo=[ {&quot;username&quot;:&quot;test123&quot;,&quot;mail&quot;:&quot;test@163&quot;,&quot;exp&quot;:&quot;无效的邮箱地址&quot;}, {&quot;username&quot;:&quot;test123&quot;,&quot;mail&quot;:&quot;&quot;,&quot;exp&quot;:&quot;邮箱不能为空&quot;}, {&quot;username&quot;:&quot;test123&quot;,&quot;mail&quot;:&quot;test_0001.com&quot;,&quot;exp&quot;:&quot;无效的邮箱地址&quot;} ] for i in datainfo: driver= webdriver.Firefox() driver.get('http://39.101.167.251/qftest-demo/') time.sleep(3) driver.find_element_by_link_text(&quot;免费注册&quot;).click() driver.find_element_by_id(&quot;username&quot;).send_keys(i[&quot;username&quot;]) driver.find_element_by_id(&quot;email&quot;).send_keys(i[&quot;mail&quot;]) driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;123456&quot;) driver.find_element_by_id(&quot;repassword&quot;).send_keys(&quot;123456&quot;) driver.find_element_by_link_text(&quot;立即注册&quot;).click() time.sleep(2) exceptvalue=i[&quot;exp&quot;] actualvalue=driver.find_element_by_xpath(&quot;/html/body/div[2]/div/div/form/div/dl[2]/dd/span&quot;).text if exceptvalue==actualvalue: print(&quot;执行成功&quot;) else: print(&quot;执行失败&quot;) driver.quit() veydows_reg_emal_false_csv: from selenium import webdriver import time import csv with open(r&quot;C:\\Users\\ASUS\\Documents\\VSCodeProject\\Python\\csv_mail.csv&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f: datainfo=csv.reader(f) for i in datainfo: driver=webdriver.Firefox() driver.get(&quot;http://39.101.167.251/qftest-demo/&quot;) driver.find_element_by_link_text(&quot;免费注册&quot;).click() driver.find_element_by_id(&quot;username&quot;).send_keys(i[0]) driver.find_element_by_id(&quot;email&quot;).send_keys(i[1]) driver.find_element_by_id(&quot;password&quot;).send_keys(i[2]) driver.find_element_by_id(&quot;repassword&quot;).send_keys(i[3]) driver.find_element_by_link_text(&quot;立即注册&quot;).click() time.sleep(2) exp=&quot;http://39.101.167.251/qftest-demo/user/index.html&quot; exceptvalue=i[4] actualvalue=driver.find_element_by_xpath(&quot;/html/body/div[2]/div/div/form/div/dl[2]/dd/span&quot;).text if exceptvalue==actualvalue: print(&quot;执行成功&quot;) else: print(&quot;执行失败&quot;) driver.quit() 附录: csv文件 test123,test@163,123456,123456,无效的邮箱地址 test123,,123456,123456,邮箱不能为空 test123,test_0001.com,123456,123456,无效的邮箱地址 ","tags":[],"title":"Selenium实战练习2_实现邮箱反向的注册功能","feature":"","link":"https://aoianz.github.io/post/yZzyuftmA/","stats":{"text":"3 min read","time":145000,"words":439,"minutes":3},"date":"2021-03-09 14:11:35","dateFormat":"2021-03-09"}]}