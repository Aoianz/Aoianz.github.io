{"posts":[{"content":" 每天你都有机会跟别人擦身而过，你也许对他一无所知，不过也许有一天，他会变成一个朋友或者是知己。 by《重庆森林》 ","tags":[{"name":"Think","slug":"TG-Vv40Nt","used":true,"link":"https://aoianz.github.io/tag/TG-Vv40Nt/"}],"title":"HI,陌生人","feature":"","link":"https://aoianz.github.io/post/mate/","stats":{"text":"1 min read","time":9000,"words":48,"minutes":1},"date":"2030-01-01 18:52:06","dateFormat":"2030-01-01"},{"content":"Servers for everyone. Start-ups to Enterprise. Concepts to reality. Instant setup Outstanding support DDoS Protection 100% Uptime SLA Reliable hosting Highly Affordable https://evolution-host.com Evolution Host Evolution Host is a premium VPS Hosting provider also specializing in game servers and a variety of other software. Evolution Host has been revolutionizing the hosting industry since inception by combining low prices with outstanding service. Our critically acclaimed support has become renowned for it's timely responsiveness and helpful nature. With highly satisfied clients from around the world, Evolution Host has become the go-to place for your hosting needs. Evolution Host是一家高级VPS主机提供商，也专门从事游戏服务器和各种其他软件。 自成立以来，Evolution Host一直在通过将低价格与出色的服务相结合来彻底改变托管行业。我们广受好评的支持 因其及时的响应性和乐于助人的性质而闻名。凭借来自世界各地的高度满意的客户，Evolution Host已成为您托管需求的首选之地。 Sincerely thank Evolution Host for your support.😀 真诚感谢Evolution Host 的支持😀 ","tags":[],"title":"Invent the future with Evolution Host","feature":"","link":"https://aoianz.github.io/post/EvolutionHost/","stats":{"text":"2 min read","time":67000,"words":238,"minutes":2},"date":"2022-08-19 00:00:00","dateFormat":"2022-08-19"},{"content":"磁盘管理 概述 Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： # 将系统内所有的文件系统列出来！ # 在 Linux 底下如果 df 没有加任何选项 # 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！ [root@kuangshen /]# df Filesystem 1K-blocks Used Available Use% Mounted on devtmpfs 889100 0 889100 0% /dev tmpfs 899460 704 898756 1% /dev/shm tmpfs 899460 496 898964 1% /run tmpfs 899460 0 899460 0% /sys/fs/cgroup /dev/vda1 41152812 6586736 32662368 17% / tmpfs 179896 0 179896 0% /run/user/0 # 将容量结果以易读的容量格式显示出来 [root@kuangshen /]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 869M 0 869M 0% /dev tmpfs 879M 708K 878M 1% /dev/shm tmpfs 879M 496K 878M 1% /run tmpfs 879M 0 879M 0% /sys/fs/cgroup /dev/vda1 40G 6.3G 32G 17% / tmpfs 176M 0 176M 0% /run/user/0 # 将系统内的所有特殊文件格式及名称都列出来 [root@kuangshen /]# df -aT Filesystem Type 1K-blocks Used Available Use% Mounted on sysfs sysfs 0 0 0 - /sys proc proc 0 0 0 - /proc devtmpfs devtmpfs 889100 0 889100 0% /dev securityfs securityfs 0 0 0 - /sys/kernel/security tmpfs tmpfs 899460 708 898752 1% /dev/shm devpts devpts 0 0 0 - /dev/pts tmpfs tmpfs 899460 496 898964 1% /run tmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroup cgroup cgroup 0 0 0 - /sys/fs/cgroup/systemd pstore pstore 0 0 0 - /sys/fs/pstore cgroup cgroup 0 0 0 - /sys/fs/cgroup/freezer cgroup cgroup 0 0 0 - /sys/fs/cgroup/cpuset cgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlb cgroup cgroup 0 0 0 - /sys/fs/cgroup/blkio cgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_prio cgroup cgroup 0 0 0 - /sys/fs/cgroup/memory cgroup cgroup 0 0 0 - /sys/fs/cgroup/pids cgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacct cgroup cgroup 0 0 0 - /sys/fs/cgroup/devices cgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_event configfs configfs 0 0 0 - /sys/kernel/config /dev/vda1 ext4 41152812 6586748 32662356 17% / systemd-1 - - - - - /proc/sys/fs/binfmt_misc mqueue mqueue 0 0 0 - /dev/mqueue debugfs debugfs 0 0 0 - /sys/kernel/debug hugetlbfs hugetlbfs 0 0 0 - /dev/hugepages tmpfs tmpfs 179896 0 179896 0% /run/user/0 binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc # 将 /etc 底下的可用的磁盘容量以易读的容量格式显示 [root@kuangshen /]# df -h /etc Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 6.3G 32G 17% / du Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： # 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）: # 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。 [root@kuangshen home]# du 16./redis 8./www/.oracle_jre_usage # 包括隐藏文件的目录 24./www 48. # 这个目录(.)所占用的总量 # 将文件的容量也列出来 [root@kuangshen home]# du -a 4./redis/.bash_profile 4./redis/.bash_logout ....中间省略.... 4./kuangstudy.txt # 有文件的列表了 48. # 检查根目录底下每个目录所占用的容量 [root@kuangshen home]# du -sm /* 0/bin 146/boot .....中间省略.... 0/proc .....中间省略.... 1/tmp 3026/usr # 系统初期最大就是他了啦！ 513/var 2666/www 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： # 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！ [root@www ~]# mkdir /mnt/hdc6 [root@www ~]# mount /dev/hdc6 /mnt/hdc6 [root@www ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 [root@www ~]# umount /dev/hdc6 ","tags":[{"name":"Linux","slug":"xx3kMlzK-4","used":true,"link":"https://aoianz.github.io/tag/xx3kMlzK-4/"}],"title":"Linux之磁盘管理","feature":"","link":"https://aoianz.github.io/post/7npxlctX_/","stats":{"text":"7 min read","time":372000,"words":1397,"minutes":7},"date":"2022-04-17 17:55:47","dateFormat":"2022-04-17"},{"content":"用户组管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 增加一个新的用户组使用groupadd命令 groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 实例1： # groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 实例2： # groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 修改gpasswd -a:从组内添加一个用户 -d:从组内删除一个用户成员 -M:定义组成员列表,以逗号分隔 gpasswd #gpasswd -a test nat1/*将用户test1加入到net组中*/ #gpasswd -M test2,test4 net #tail -4 /etc/group net: x:1010:test2,test4 如果要删除一个已有的用户组，使用groupdel命令 要想删除组，要确保该组不是主组，才能把这个组删掉。 如果组中有附属用户删除用户时不会删除这个组 groupdel 用户组 例如： # groupdel group1 此命令从系统中删除组group1。 修改用户组的属性使用groupmod命令 groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 # 此命令将组group2的组标识号修改为102。 groupmod -g 102 group2 # 将组group2的标识号改为10000，组名修改为group3。 groupmod –g 10000 -n group3 group2 切换组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： $ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。 /etc/passwd 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 下面分别介绍这些文件的内容。 /etc/passwd文件是用户管理工作涉及的最重要的一个文件。 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子： ＃ cat /etc/passwd root:x:0:0:Superuser:/: daemon:x:1:1:System daemons:/etc: bin:x:2:2:Owner of system commands:/bin: sys:x:3:3:Owner of system files:/usr/sys: adm:x:4:4:System accounting:/usr/adm: uucp:x:5:5:UUCP administrator:/usr/lib/uucp: auth:x:7:21:Authentication administrator:/tcb/files/auth: cron:x:9:16:Cron daemon:/usr/spool/cron: listen:x:37:4:Network daemon:/usr/net/nls: lp:x:71:18:Printer administrator:/usr/spool/lp: 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 1）&quot;用户名&quot;是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(😃，因为冒号在这里是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 2）“口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 3）“用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 4）“组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 5)“注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。 6)“主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 8)系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪 用 户 含 义 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有帐户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NFS使用 /etc/shadow 1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。 2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用&quot;:&quot;隔开。这些字段是： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 &quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号 &quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 &quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 &quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。 &quot;最大时间间隔&quot;指的是口令保持有效的最大天数。 &quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 &quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。 &quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/group 用户组的所有信息都存放在/etc/group文件中。 将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。 每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 &quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 &quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 &quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。 &quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 ","tags":[{"name":"Linux","slug":"xx3kMlzK-4","used":true,"link":"https://aoianz.github.io/tag/xx3kMlzK-4/"}],"title":"Linux之用户组管理","feature":"","link":"https://aoianz.github.io/post/SAeD1f6Fr/","stats":{"text":"12 min read","time":679000,"words":3101,"minutes":12},"date":"2022-04-17 17:55:12","dateFormat":"2022-04-17"},{"content":"账号管理 简介 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。 添加账号 useradd useradd 选项 用户名 useradd -d /home/user01 user01 参数说明： 选项 : -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -m 使用者目录如不存在则自动建立。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 测试： # 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen [root@kuangshen home]# useradd -m kuangshen 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 Linux下如何切换用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 删除帐号 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 [root@kuangshen home]# userdel -r kuangshen 此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/ksh -d /home/z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： $ passwd Old password:****** New password:******* Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： # passwd kuangshen New password:******* Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： # passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： # passwd -l kuangshen ","tags":[{"name":"Linux","slug":"xx3kMlzK-4","used":true,"link":"https://aoianz.github.io/tag/xx3kMlzK-4/"}],"title":"Linux之账号管理","feature":"","link":"https://aoianz.github.io/post/ZG7MhpK5J/","stats":{"text":"6 min read","time":323000,"words":1498,"minutes":6},"date":"2022-04-17 17:54:34","dateFormat":"2022-04-17"},{"content":"目录管理 绝对路径和相对路径 我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 在开始本教程前我们需要先知道什么是绝对路径与相对路径。 绝对路径： 路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令 接下来我们就来看几个常见的处理目录的命令吧： ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls （列出目录） 在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ cd （切换目录） cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对路径或绝对路径] 测试： # 切换到用户目录下 [root@kuangshen /]# cd home # 使用 mkdir 命令创建 kuangstudy 目录 [root@kuangshen home]# mkdir kuangstudy # 进入 kuangstudy 目录 [root@kuangshen home]# cd kuangstudy # 回到上一级 [root@kuangshen kuangstudy]# cd .. # 回到根目录 [root@kuangshen kuangstudy]# cd / # 表示回到自己的家目录，亦即是 /root 这个目录 [root@kuangshen kuangstudy]# cd ~ 接下来大家多操作几次应该就可以很好的理解 cd 命令的。 pwd ( 显示目前所在的目录 ) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 [root@kuangshen kuangstudy]#pwd [-P] 选项与参数：-P ：显示出确实的路径，而非使用连接(link) 路径。 测试： # 单纯显示出目前的工作目录 [root@kuangshen ~]# pwd /root # 如果是链接，要显示真实地址，可以使用 -P参数 [root@kuangshen /]# cd bin [root@kuangshen bin]# pwd -P /usr/bin mkdir （创建新目录） 如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 测试： # 进入我们用户目录下 [root@kuangshen /]# cd /home # 创建一个 test 文件夹 [root@kuangshen home]# mkdir test # 创建多层级目录 [root@kuangshen home]# mkdir test1/test2/test3/test4 mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory # &lt;== 没办法直接创建此目录啊！ # 加了这个 -p 的选项，可以自行帮你创建多层目录！ [root@kuangshen home]# mkdir -p test1/test2/test3/test4 # 创建权限为 rwx--x--x 的目录。 [root@kuangshen home]# mkdir -m 711 test2 [root@kuangshen home]# ls -l drwxr-xr-x 2 root root 4096 Mar 12 21:55 test drwxr-xr-x 3 root root 4096 Mar 12 21:56 test1 drwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir ( 删除空的目录 ) 语法： rmdir [-p] 目录名称 选项与参数：**-p ：**连同上一级『空的』目录也一起删除 测试： # 看看有多少目录存在？ [root@kuangshen home]# ls -l drwxr-xr-x 2 root root 4096 Mar 12 21:55 test drwxr-xr-x 3 root root 4096 Mar 12 21:56 test1 drwx--x--x 2 root root 4096 Mar 12 21:58 test2 # 可直接删除掉，没问题 [root@kuangshen home]# rmdir test # 因为尚有内容，所以无法删除！ [root@kuangshen home]# rmdir test1 rmdir: failed to remove ‘test1’: Directory not empty # 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。 [root@kuangshen home]# rmdir -p test1/test2/test3/test4 注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！ cp ( 复制文件或目录 ) 语法： [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： **-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) **-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)； **-d：**若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； **-r：**递归持续复制，用於目录的复制行为；(常用) **-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) **-l：**进行硬式连结(hard link)的连结档创建，而非复制文件本身。 **-s：**复制成为符号连结档 (symbolic link)，亦即『捷径』文件； **-u：**若 destination 比 source 旧才升级 destination ！ 测试： # 找一个有文件的目录，我这里找到 root目录 [root@kuangshen home]# cd /root [root@kuangshen ~]# ls install.sh [root@kuangshen ~]# cd /home # 复制 root目录下的install.sh 到 home目录下 [root@kuangshen home]# cp /root/install.sh /home [root@kuangshen home]# ls install.sh # 再次复制，加上-i参数，增加覆盖询问？ [root@kuangshen home]# cp -i /root/install.sh /home cp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖 rm ( 移除文件或目录 ) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 测试： # 将刚刚在 cp 的实例中创建的 install.sh删除掉！ [root@kuangshen home]# rm -i install.sh rm: remove regular file ‘install.sh’? y # 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！ # 尽量不要在服务器上使用 rm -rf / mv ( 移动文件与目录，或修改名称 ) 语法： [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： # 复制一个文件到当前目录 [root@kuangshen home]# cp /root/install.sh /home # 创建一个文件夹 test [root@kuangshen home]# mkdir test # 将复制过来的文件移动到我们创建的目录，并查看 [root@kuangshen home]# mv install.sh test [root@kuangshen home]# ls test [root@kuangshen home]# cd test [root@kuangshen test]# ls install.sh # 将文件夹重命名，然后再次查看！ [root@kuangshen test]# cd .. [root@kuangshen home]# mv test mvtest [root@kuangshen home]# ls mvtest 基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用&quot;d&quot;表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限； 第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限； 第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 3、chmod：更改文件9个属性 chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx---] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= --- = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ ","tags":[{"name":"Linux","slug":"xx3kMlzK-4","used":true,"link":"https://aoianz.github.io/tag/xx3kMlzK-4/"}],"title":"Linux之目录管理与基本属性","feature":"","link":"https://aoianz.github.io/post/QRa65rZHu/","stats":{"text":"12 min read","time":670000,"words":2833,"minutes":12},"date":"2022-04-17 17:52:42","dateFormat":"2022-04-17"},{"content":"文件内容查看 概述 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： # 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/ [root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 BOOTPROTO=dhcp ONBOOT=yes tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0 ONBOOT=yes BOOTPROTO=dhcp DEVICE=eth0 nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： [root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0 1DEVICE=eth0 2BOOTPROTO=dhcp 3ONBOOT=yes more 一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 [root@kuangshen etc]# more /etc/csh.login ....(中间省略).... --More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； [root@kuangshen etc]# more /etc/csh.login ....(中间省略).... : # 这里可以等待你输入命令！ head 取出文件前面几行 语法： head [-n number] 文件 选项与参数：-n 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@kuangshen etc]# head -n 20 /etc/csh.login tail 取出文件后面几行 语法： tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： [root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： [root@kuangshen /]# cd /home [root@kuangshen home]# touch f1 # 创建一个测试文件f1 [root@kuangshen home]# ls f1 [root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2 [root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3 [root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1 397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2 397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 # echo 字符串输出 &gt;&gt; f1 输出到 f1文件 [root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1 [root@kuangshen home]# cat f1 I am f1 file [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 I am f1 file [root@kuangshen home]# rm -f f1 [root@kuangshen home]# cat f2 I am f1 file [root@kuangshen home]# cat f3 cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： 上手体验一下，在home目录下测试 如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做： [root@kuangshen home]# vim kuangstudy.txt 然后就会进入文件 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字 在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。 按下 ESC 按钮回到一般模式 好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！ 在一般模式中按下 :wq 储存后离开 vim！ OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。 Vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n&lt; space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！(常用) n&lt; Enter&gt; n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ ","tags":[{"name":"Linux","slug":"xx3kMlzK-4","used":true,"link":"https://aoianz.github.io/tag/xx3kMlzK-4/"}],"title":"Linux之文件内容查看","feature":"","link":"https://aoianz.github.io/post/GEzxJQikV/","stats":{"text":"18 min read","time":1056000,"words":4724,"minutes":18},"date":"2022-04-17 17:26:22","dateFormat":"2022-04-17"},{"content":" 软件设计风格: 本软件采用明亮的黄色作为软件主题色 明亮快活，洋溢活力，注入了太阳能量的暖黄色调 ","tags":[{"name":"Android","slug":"wFZpTJOOV","used":true,"link":"https://aoianz.github.io/tag/wFZpTJOOV/"}],"title":"Android开发小作品：一本记账.app","feature":"","link":"https://aoianz.github.io/post/qWwCxcaUG/","stats":{"text":"1 min read","time":8000,"words":43,"minutes":1},"date":"2021-10-18 08:59:07","dateFormat":"2021-10-18"},{"content":"2.1数据库基础知识 1.Dos登录 命令:mysql -h hostname -u username -p 例如:mysql -h 123 -uroot -p 简写:mysql -u root -p 复合主键 就是指你表的主键含有一个以上的字段组成 &gt; create table test &gt; ( &gt; name varchar(19), &gt; id number, &gt; value varchar(10), &gt; primary key (name,id) &gt; ) 上面的name和id字段组合起来就是你test表的复合主键 它的出现是因为你的name字段可能会出现重名，所以要加上ID字段这样就可以保证你记录的唯一性 一般情况下，主键的字段长度和字段数目要越少越好 2.1.1创建和查看数据库 创建数据库 语法:create database 数据库名称; create database itcast;/*创建数据库itcast:*/ 查看数据库 语法:show databases/*查看数据库*/ 查看某个数据库 语法:show create database 数据库名称; 例如:show create database itcase;/*查看数据库itcase信息*/ 使用数据库 语法:use 数据库名称; 例如:use itcast;/*使用数据库itcast*/ 2.1.2修改数据库 alter 数据库名称;修改数据库 语法:alter database 数据库名称 default character set 编码方式 collate 编码方式_bin 例如:修改数据库,将数据库itcast的编码修改为gbk &gt; alter database itcast default character set gbk collate gbk_bin; 2.1.3删除数据库 语法:drop database 数据库名称; 例如:drop database itcast;/*删除名称为itcast的数据库*/ 2.2数据类型 2.2.1 整数类型 1.在MySQL数据库中，经常需要存储整数数值。根据数值取值范围的不同，MySQL中的整数类型可分为5种，分别是 TINYINTtinyint、SMALLINT、 MEDIUMINT、INT和BIGINT。不同整数类型的取值范围可以根据字节数计算出来，例如， TINYINT类型的整数占用1个字节，1个字节是8位，那么，TINYINT类型无符号数的最大值就是28-1，即255。 同理可以算出其它不同整数类型的取值范围。 **注意:**在足够使用的情况下选择选择尽量小的数据类型 2.2.2浮点数类型与定点数类型 2.在MySQL数据库中，存储的小数都是使用浮点数和定点数来表示的。浮点数的类型有两种，分别是单精度浮点数类型(float)和双精度浮点类型(double)。而定点数类型只有decimal，类型。 浮点型:非精准数据类型,有误差 定点型:精准类型 2.2.3日期与时间类型 3.为了方便在数据库中存储日期和时间，MySQL提供了表示日期和时间的数据类型,分别是YEAR、DATE、TIME、DATETIME和timestamp year:1字节 例如:year 2014 ='2014' p35 '00'~'69' 20?? 58= 2058 '70'~'99' 19?? 89 =1989 1.YEAR类型:(字符串类型与数字类型)'2020' 2020 '00-99' 1-99 2.DATE类型: '2020-06-21' '20200621' current_data或now()/表示当前日期/ 3.TIME类型:表示时间值 格式:HH:MM:SS current_data或now()表示当前系统时间 4.DATATIME类型 now()表示当前日期和时间 5.TIMESTAMP类型 与DATATIME类型显示形式相似,但取值范围比DATATIME类型小 2.2.4 字符串和二进制类型 为了存储字符串、图片和声音等数据，MySQL提供了字符串和二进制类型。包括CHAR和VARCHAR类型、BINARY和VARBINARY类型、TEXT类型、BLOB类型ENUM类型、SET类型和BIT类型 1.CHAR和VARCHAR类型: ​ CHAR和VARCHAR类型都用来表示字符串数据,VARCHAR可以储存可变字符串 语法:CHAR(M)或VARVCHAR(M) M指字符串的最大长度; VARCHAR(4)所对应的数据所占用的字节数为实际长度加1; char:浪费时间,但查询速度快; varchar:节约空间,但查询速度慢 '' '' 4个字节 '' 1个字节 'ab' 'ab' 4个字节 'ab' 2个字节 'abc' 'abc' 4个字节 'abc' 3个字节 'abcd' 'abcd' 4个字节 'abcd' 4个字节 'abcdef' 'abcd' 4个字节 'abcd' 5个字节 2.BINARY和VARBINARY类型: ​ BINARY和VARBINARY类型类似CHAR和VARCHAR类型,不同的是,它们表示二进制数据 语法:BINARY(M)或VARBINARY(M) M指二进制数据的最大字节长度; 注意:BINARY类型的长度是固定的,如果数据的长度不足最大长度,将在数据的后面用&quot;\\0&quot;补齐,最终达到指定长度. 例如,指定数据的类型是BINARY(3),当插入a时,实际储存的数据为&quot;a\\0\\0&quot;,当插入ab时,实际储存的数据是&quot;ab\\0&quot;; 3.TEXT类型: TEXT类型用来表示大文本数据,例如,文章内容、评论等,它的类型分为4种; 数据类型 储存范围 数据类型 储存范围 TINYTEXT 0-255字节 MEDIUMTEXT 0-16777215字节 TEXT 0-65535字节 LONGTEXT 0-4294967295字节 4.BLOB类型: ​ BLOB类型是一种特殊的二进制类型,它用于表示数据量大很大的二进制数据,例如 图片、PDF文档等 数据类型 储存范围 数据类型 储存范围 TINYBLOB 0-255字节 MEDIUMBLOB 0-16777215 BIOB 0-65535字节 LONGBILOB 4294967295 注意:BLOB类型数据是根据二进制编码进行比较和排序,而TEXT类型数据是根据文本模式进行比较和排序 5.ENUM类型: ENUM类型又称为枚举类型 ENUM('值1','值2','值3',...'值n') 注意:MYSQL中存入的是这个顺序编号,而不是列表中的值 6.SET类型: SET类型用于表示字符串对象,它的值可以有零个或多个,SET类型数据的定义格式与ENUM类型相似 语法:SET('值1','值2','值3',...'值n') 注意:MYSQL中存入的是这个顺序编号,而不是列表中的值 7.BIT类型: ​ 用于表示二进制数据 语法:BIT(M) M用于表示每个值的位数,范围是1-64; 注意:如果分配的BIT(M)类型的数据的长度小于M,将在数据的左边用0补齐 例如,为BIT(6)分配值b'101'与分配b'000101'相同 2.3创建数据表 create database student;/*创建名为student*/ use itcase;/*使用数据库*/ create TABLE tb_grade/*创建名为tb_gradea的数据表*/ ( id INT(11),/*举例*/ name VARCHER(20), grade FLOAT ); show tables;/*验证数据库是否创建成功*/ show create table tb_greade;/*查看数据表创建时的定义语句,查看表的字符编码*/ describe tb_greade;/*查看表的字段信息,包括字段名、字段类型等信息*/ 修改数据表 ​ 1.修改表名; alter table 表名 rename 新表名; alter table tb_grade rename(to) grade; ​ 2.修改字段名; alter table 表名 change 旧字段名 新字段名 新数据类型; alter table grade change name username verchar(20);/*name字段改为username,数据类型保持不变*/ desc greade;/*验证*/ ​ 3.修改字段的数据类型; alter table 表名 modify 字段名 数据类型; alter table grade modify id int(20);/**/ ​ 4.添加字段; alter table 表名 add 新字段名 数据类型 [约束条件][first|after 已存在的字段名] alter table grade add age int(10); alter table grade add age int(10) first;/*添加到第一位*/ alter table grade add age int(10) after id;/*添加到id后面*/ alter table grade add age int(10) not null first;/*不允许为空*/ ​ 5.删除字段; alter table 表名 drop 字段名; alter table grade drop age; ​ 6.修改字段的排列位置; alter table 表名 modify 字段名1 数据类型 first|after 字段名2; 字段名1 指要修改位置的字段; first是可选参数,指的是将字段1修改为表的第一个字段; after 字段名2 是将字段1插入到字段2后面; alter table grade modify id int(10) after grade;/*将id字段插入到grade字段后面*/ 删除数据表 drop table 表名; drop table grade; desc table grade;/*验证*/ 2.4表的约束 防止数据表中插入错误的数值,而定义的维护数据库完整性的规则 约束条件 说明 PRIMARY KEY 主键约束，用于唯一标识对应的记录(主键唯一表示,值不能为空null ); FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 2.4.1 主键约束; 注意:每个数据表中最多只能有一个主键约束,定义为primary key的字段不能有重复值且不能为null值 1.单字段约束 语法: 字段名 数据类型 PRIMARY KEY 例如:创建一个数据表ex1,并设置id作为主键,SQL语句如下: CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20), grade FLOAT ); 2.多字段主键 语法:PRIMARY KAY(字段名1,字段名2,***字段名n) 例如:创建一个数据表ex2,在表中将stu_id和course_id两个字段共同作为主键,SQL语句如下: CREATE TABLE ex2( stu_id INT, course_id FLOAT, PRIMARY KEY(stu_id,course_id) ); 2.4.2非空约束 非空约束指的是字段的值不能为null,在MySQL中,非空约束是通过NOT NULL定义的; 语法: 字段名 数据类型 NOT NULL; 例如:CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT not null ); 2.4.3唯一约束 保证数据表中字段的唯一性,即表中字段的值不能重复出现 语法: 字段名 数据类型 UNIQUE; CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT UNIQUE ); ID为主键,name的字段不能为空值,grade字段为唯一值,该值不能重复 2.4.4默认约束 用于给数据表中的字段添加指定默认值 语法:字段名 数据类型 DEFAULT 默认值; 例如:CREATE TABLE ex1( id INT PRIMARY KEY, name VARCHAR(20) NOT NULL, grade FLOAT default 0/*默认值为0*/ ); 2.5设置表的字段值自动增加 在数据表中，若想为表中插入的新记录自动生成唯一的ID，可以使用AUTO_INCREMENT约束来实现。 AUTO_INCREMENT约束的字段可以是任何整数类型，默认情况下，该字段的值是从1开始自增的 语法: 字段名 数据类型 AUTO_INTCREMENT; 例如:创建一个数据表ex5,将表中的id字段设置为自动增加,SQL语句如下: CREATE TABLE ex1( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) NOT NULL, grade FLOAT UNIQUE ); 2.6索引 2.6.1索引的概念 数据库的索引好比新华字典的音序表，它是对数据库表中一列或多列的值进行排序后的一种结构，其作用就是提高表中数据的查询速度 1.普通索引 普遍索引是由KEY或INDEX定义的索引，它是MySQL中的基本索引类型,可以创建在任何数据类型中，其值是否唯一和非空 由字段本身的约束条件所决定。 2.唯一性索引 唯一性索引是由UNIQUE定义的索引,该索引所在字段的值必须是唯一的。 3.全文索引/文本/ 全文索引是由FULLTEXT定义的索引，它只能创建在CHAR、VARCHAR或TEXT类型的字段上,而且,现在只有MyISAM存储引擎支持全文索引。 4.单列索引 单列索引指的是在表中单个字段上创建索引，它可以是普通索引、唯一索引或者全文索引,只要保证该索引只对应表中一个字段即可。 5.多列索引 多列索引指的是在表中多个字段.上创建索引，只有在查询条件中使用了这些字段中的第一个字段时,该索引才会被使用。 6.空间索引 空间索引是由SPATIAL定义的索引，它只能创建在空间数据类型的字段上。创建时必须声明为not null,并且只有MyISAM存储引擎支持 2.6.2 创建索引 &gt; 1.创建表的时候创建索引 语法:CREATE TABLE 表名(字段名 数据类型 [完整性约束条件], 字段名 数据类型 [完整性约束条件], ... 字段名 数据类型 [UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY [别名] (字段名1 [(长度)] [ASC|DESC]) ); UNIQUE:可选参数，表示唯一索引 FULLTEXT:可选参数，表示全文索引 SPATIAL:可选参数，表示空间索引 INDEX和KEY:用来表示字段的索引，二者选一即可 ASC和DESC可选参数，ASC表示升序排列，DESC表示降序排列 别名:可选参数，表示创建的索引的名称 字段名1:指定索引对应字段的名称， 长度:可选参数，用于表示索引的长度 &gt;1.创建普通索引 mysql&gt; create table t2( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; index index(id asc)/*创建名为index的索引,升序排列*/ -&gt; ); 建立后,使用show create table查看表的结构 ==show create table t1\\G; t1\\G 使排列有序 为了查看索引是否被使用可以使用explain语句进行查看,SQL代码如下: explain select * from t1 while id=1 \\G &gt;2.创建唯一性索引 mysql&gt; create table t2( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; unique index unique_id(id asc)/*在表中id字段上建立索引名为unique_id的唯一性索引,并且按照升序排序*/ -&gt; ); &gt;3.创建全文索引 mysql&gt; create table t1( -&gt; id int(11), -&gt; name varchar(20), -&gt; grade float, -&gt; fulltext index fulltext_name(name) -&gt; )engine=myisam;/*因为目前只有MyISAM存储引擎支持全文索引*/ &gt;4.创建单列索引 mysql&gt; create table t4( -&gt;name varchar(20) not null, -&gt; score float, -&gt; index single_name(name(20))/*在name字段上创建一个名叫single_name的单列索引索引长度为20*/ -&gt; ); &gt;5.创建多列索引 mysql&gt; create table t5( -&gt;id int not null, -&gt;name varchar(20) not null, -&gt; score float, -&gt; index multi(id,name(20))/*在id和name字段上创建一个名叫multi的多列索引*/ -&gt; ); 注意:在多列索引中,只有查询条件中使用了这些字段的第一个字段时多列索引才会被使用 &gt;6.创建空间索引 mysql&gt; create table t6( -&gt;id int, -&gt;space geometry not null, -&gt;spatial index sp(space)/*在space字段上建立一个名为sp的空间索引*/ -&gt;)engine=myisam; 注意:创建空间索引时,所在字段不能为空值,并且表的储存引擎为myisam 2.使用CREATE INDEX语句在已经存在的表上创建索引 语法CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 ON 表名 (字段名 [(长度)] [ASC|DESC]); mysql&gt; create table book( -&gt; bookid int not null, -&gt; bookname varchar(255) not null, -&gt; authors varchar(255) not null -&gt; info varchar(255) null, -&gt; comment varchar(255) null, -&gt; publicyear year not null -&gt; ); &gt;1.创建普通索引 mysql&gt; create index index_id on book(bookid);/*在book表中的bookid字段上建立一个名为index_id的普通索引*/ mysql&gt; show create table book\\g;/*查看数据表结构*/ &gt;2.创建唯一性索引 create unique index uniqueidx on book(bookid); /*在bookid字段上创建一个名为uniqueidx的唯一性索引*/ &gt;3.创建单列索引 create index singleidx on book(comment); /*在comment字段上创建一个名称为singleidx的单列索引*/ &gt;4.创建多列索引 create index mulitidx on book(authors(20)),info(20)); /*在authors和info字段上创建一个名称为mulitidx的多列索引*/ &gt;5.创建全文索引 create fulltext index fulltextidx on book(info); /*在info字段上创建名为fulltextidx的全文索引*/ &gt;6.创建空间索引 create table t7( g geometry not null )engine=myisam; create spatail index spatidx on t7(g);/*在g字段上创建名称为spatidx的空间索引*/ 3.使用ALTER TABLE 语句在已经存在的表上创建索引 语法:ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 (字段名[(长度)] [ASC|DESC] ) create table book( bookid int not null, bookname varchar(255) not null, authors varchar(255) null, comment varchar(255) null, pubblicyear year not null ); &gt;1.创建普通索引 alter table book add index id(bookid); &gt;2.创建唯一性索引 alter table book add unique uniqueidx(bookid); &gt;3.创建单列索引 alter table book add index singleidx(comment(50)); &gt;4.创建多列索引 alter table book add index multidx(authors(20),info(50)); &gt;5.创建全文索引 alter table book add fulltext index fulltextidx(info); &gt;6.创建空间索引 create table t8( space geometry not null )engine=myisam; alter table t8 add spatial index spatidx(space); 2.6.3删除索引 &gt; 1.使用alter table删除索引 语法:alter table 表名 drop index 索引名; 例如: 删除表book中名叫fulltextidx的全文索引 alter table book drop index fulltextidx; &gt; 2.使用 drop index删除索引 语法:drop index 索引名 on 表名; 3.1添加数据 &gt; 3.1.1为表中所有字段添加数据; &gt; 1.insert语句中指定所有字段名 向表中添加新记录时,可以在insert语句中列出表中的所以字段名; 注意:必须列出表中所以的字段名称,&quot;值1,值2,..&quot;的顺序,类型必须与对应的字段相匹配 语法:insert into 表名(字段名1,字段名2,...) values(值1,值2,...); 验证数据是否成功使用select语句查看student表中的数据 select * from 表名; &gt; 2.insert语句中不指定字段名 注意:由于insert语句中没有指定字段名,添加的值的顺序必须和字段在定义的顺序相同 语法: insert into 表名 values(值1,值2,...); &gt;3.1.2为表中指定的字段添加数据 语法: insert into 表名(字段1,字段2,...) values(值1,值2) &gt;3.1.3同时添加多条记录 语法:insert into 表名 [(字段名1,字段名2,...)] values(值1,值2,...), (值1,值2,...), (值1,值2,...); 例如: 向student表中添加三条新纪录,insert语句如下: mysql&gt; insert into student values -&gt; (6,'lilei',99), -&gt; (7,'hanmeimei',100), -&gt; (8,'poly',40.5); 3.2更新数据 语法: update 表名 set字段名1=值1[,字段2=值2,...] [where条件表达式] &gt; 1.update 更新部分数据 例如:更新student表中id字段值为1的记录,将记录中的name字段的值更改为'caocao',grade字段的值更改为50; mysql&gt; update student &gt; set name='caocao',grade=50 &gt; where id=1 &gt; 2.update 更新全部数据 例如:将student表中全部记录,将grade字段值都变为100: &gt;update student &gt;set grade=100 3.3 删除数据 delete from 表名[where 条件表达式] &gt;1.删除部分数据 &gt;delete from 表名 &gt;where 条件表达式 例如:删除表student上id字段上小于4的记录 &gt;delete from student &gt;where id&lt;4; &gt;2.删除全部数据 &gt;1.delete delete from 表名; &gt;2.truncate truncate from 表名; 区别: delete语句后跟where子句,可以删除部分记录,truncate只能删除表中全部记录 delete语句删除数据后,再次向表中增加记录时,自动增加字段的值为删除时该字段的最大值加1,truncate语句删除数据后,自动字段的默认初始值重新由1开始; 4.1 简单查询 &gt;4.1.1 select 语句 语法 //顺序不能颠倒 mysql&gt; &gt; select [distinct] * |字段名1,字段名2,字段名3,... &gt; from 表名 &gt; [where 条件表达式1] &gt; [group by 字段名 [having条件表达式2]] &gt; [order by 字段名 [asc|desc]] &gt; [limit [offset] 记录数] &gt;4.1.2 查询所有字段 &gt; 1.在select语句中指定所有字段 语法:select 字段名1,字段名2,...from 表名 &gt; 2.在select语句中使用星号(*)通配符代替所有字段 select * from 表名 &gt;4.1.3 查询指定字段 语法: select 字段名1,字段名2,...from 表名; 4.2 按条件查询 &gt;4.2.1带关系运算符查询 where 子句中指定查询条件对数据进行过滤 语法:select 字段名1,字段名2,... from 表名 where 条件表达式 &gt;4.2.2 带in关键字的查询 in关键字用于判断某个字段的值是否在指定集合中 语法:select * |字段名1,字段名2,... from 表名 where 字段名[not] in (元素1,元素2) &quot;元素1,元素2&quot;表示集合中的元素,即指定的条件范围 not 为可选参数,使用not表示查询不在in关键字指定集合范围的记录 例如:查询student表中ID值为1,2,3的记录 mysql&gt; select id,grade,name,grade from student where id in(1,2,3); &gt;4.2.3带between and 关键字查询 between and 用于判断某个字符的值是否在指定的范围之内,如果字段的值在指定的范围内,则满足条件 select * |{字段名1,字段名2,...} from 表名 where 字段名 [not] between 值1 and 值2 例如: 查询student表中id值在2~5之间的学生姓名 mysql&gt; select id,name from student where id between 2 and 5; &gt;4.2.4 空值查询 在数据表中,某些列的值可能为空值(null),空值不同于0,也不同于空字符串 在mysql中,使用is null关键字来判断是否为空值 语法:select * |字符段1,字符段2,... from 表名 where 字段名 is [not] null; 例如:查询Student表中gender为空值的记录 mysql&gt; select id,name,grade,gender from student where gender is null; &gt;4.2.5 带distinct关键词的查询 很多表中某些字段的数据存在重复的值,使用distinct过滤重复记录的字段 例如:在student表中查询gender(性别)字段的值,查询记录不能重复; mysql&gt; select distinct gender from student; distinct关键字作用于多个字段,如果字段名1字段名2里的值都相同才被认为是重复记录 语法:select distinct 字段名1,字段名2,...from 表名; &gt;4.2.6 带like关键字的查询 使用关系运算符&quot;=&quot;可以判断两个字符串是否相等,但有些需要是对字符串进行模糊查询 select * | {字符段1,字符段2,...} from 表名 where 字段名 [not] like '匹配字符串'; 1. 百分号(%) 通配符 作用 : 匹配任意长度的字符串 ,包括空字符串 例1: 查询student表中name字段值以字符&quot;s&quot;开头的学生 id mysql&gt; select id, name from student where name like &quot;s%&quot; ; 例2:查询student表中name字段值以字符&quot;w&quot;开头,以字符&quot;g&quot;结束的学生 id mysql&gt; select id, name from student where name like &quot;w%g&quot; ; 例3:查询student表中name字段值包括字符&quot;y&quot;的学生 id; mysql&gt; select id, name from student where name like &quot;%y%&quot; ; 2. 下划线(_) 通配符 作用 : 下划线通配符只能匹配单个字符,如果需要匹配多个则需要使用多个下划线 例1: 查询student表中name字段值以字符串&quot;wu&quot;开始, 以字符串&quot;ong&quot;结尾,并且两个字符串之间只有一个字符的记录 mysql&gt; select * from student where name like &quot;wu_ong&quot;; 例2: 查询student表中name字符值包括7个字符, 并且以字符串&quot;ing&quot;结尾的记录 mysql&gt; select * from student where name like &quot;_______ing&quot;; 3.使用百分号和下划线通配符进行查询操作 作用 : 通过右斜线( &quot; \\ &quot; )对百分号和下划线进行转义 例如 : &quot;%&quot;匹配百分号字符值 , &quot; \\ _ &quot;匹配下划线字符值 例如: 查询student表中name字段值包括&quot;%&quot;的记录; mysql&gt; insert into student (name,grade,gender) -&gt; values ('sun%er',95,'男'); mysql&gt; select * from student where name like &quot;%\\%%&quot;; &gt;4.2.7 带and关键字的多条件查询 and关键字连接两个或以上查询条件 例如:select * from 表名 where 条件表达式1 and 条件表达式2 [...and 条件表达式n] 查询student表中id字段值在1.2.3.4之中,name字符值以字符串'ng'结尾,并且grade字段值小于80的记录 mysql&gt; select id,name,grader,gender -&gt; from student -&gt; where id in(1,2,3,4) and name like '%ng' and grade &lt;80; &gt;4.2.8 带or关键字的多条件查询 or关键字满足一个,可以连接两个或多个查询条件 例如:查询student表中满足条件name字段值以字符'h'结束,或者gender字符值为'女',或者grade字段值为100的记录 mysql&gt; select id,name,grade,gender -&gt; from student -&gt; where name like '%h' or gender='女' or grade=100; 注意:or和and可以一起使用, and优先级高于or 例如:查询student表中student字符值为'女'或者gender字符值为'男',并且gender字段值为100的学生姓名 mysql&gt; select name,grade,gender -&gt; from student -&gt; where gender='女' or gender ='男' and grade=100; 4.3 高级查询 &gt;4.3.1 聚合函数 &gt;1.count()函数 COUNT()函数用来统计记录的条数，其语法格式如下所示: SELECT COUNT(*) FROM 表名; 例如: 查询student表中一共有多少条记录 mysql&gt; select count(*) from student; &gt;2.sum()函数 SUM()是求和函数，用于求出表中某个字段所有值的总和，其语法格式如下: SELECT SUM(字段名) FROM 表名 例如:求出student表中grade字段的总和 mysql&gt; select sum(grade) from student7 &gt;3.avg()函数 AVG()函数用于求出某个字段所有值的平均值其语法格式如下所示: SELECT AVG(字段名) FROM student; 例如:求出student表中grade字段的平均值 &gt;select avg(grade) from student &gt;4.max()函数 MAX()函数是求最大值的函数，用于求出某个字段的最大值，其语法格式如下所示: SELECT MAX(grade) FROM student; 例如:求出student表中grade字段的最大值 &gt;select max(grade) from student &gt;5.min()函数 MIN()函数是求最小值的函数，用于求出某个字段的最小值，其语法格式如下所示: SELECT MIN(grade) FROM student; 例如:求出student表中grade字段的最小值 &gt;select min(grade) from student &gt;4.3.2 对查询结果排序 ​ 从表中查询出来的数据可能是无序的,或者排列顺序不是用户期望的,为了使查询结果满足用户的要求,可以使用order by ​ 对查询结果进行排序,语法格式如下: 使用 ORDER BY对查询结果进行排序其语法格式如下所示: SELECT字段名1, 字段名2, FROM 表名 ORDER BY字段名1 [ASC|DESC]，字段名2 [ASC|DESC] /*asc:升序,从小到大,desc:倒叙,从大到小*/ 例2:查询student表中的所有记录,按照gender字段的升序和grade字段的降序进行排序: mysql&gt; select * from student -&gt; order by gender asc, grade desc; ==注意:==在按照指定字段进行升序排列时，如果某条记录的字段值为NULL，则这条记录会在第一条显示，这是因为NULL值可以被认为是最小值 &gt; 4.3.3 分组查询 &gt;1.单独使用group by 分组 单独使用group by 关键词,查询的是每个分组的一条记录 例如:查询student表中的记录,按照gender字段值进行分组 select * from student group by gender; 查询结果是按照gender字段中的不同值进行分类的,查询结果只显示每个分组 &gt;2.group by和聚合函数一起使用 gruop by 和聚合函数一起使用可以统计出某个或者某些字段在一个分组中的最大值,最小值,平均值等 例如:将student表中gender字段值进行分组查询,计算出每个分组中各有多少名学生 select count(*),gender from student group by gender; 例如:将student表中gender字段值进行分组查询,计算出每个分组的总成绩,平均成绩,最高分,最低分 select sum(grade),avg(grade),max(grade),min(grade),genter from student3 group by genter; &gt;3. group by 和 having关键词一起使用 having关键字和 where关键字的作用相同,都设置条件表达式对查询结果进行过滤,两者区别在于, having关键字后可以跟聚合函数,而where 关键字不能 例如:将student表中按照gender字段进行分组查询,查找grade字段值之和小于300的分组 select student sum(grade),gender from student group by gender having sum(grade)&lt;300 &gt;4.3.4 使用limit限制查询结果的数量 查询数据时,可能会返回很多条记录,而用户需要的记录可能只是其中的一条或者几条,比如实现分页功能,每页显示10行信息,每次查询都需要查出10条记录 格式:select 字段名1,字段名2,... from 表名 limit [offset,] 记录数 //limit后可以跟两个参数,第一个参数offset表示偏移量,如果为0则从查询结果的第一条开始记录,偏移量为1则从查询结果中的第二条记录开始,以此类推;offset为可选值,如果不指定其默认值为0.第二个参数&quot;记录数&quot;表示返回查询记录的条数; 例(1):查询Student表中的前四条记录 select * from student limit 4; //没有指定返回记录的偏移量,只指定了查询记录的条数4,因此返回结果从第一条开始,一共返回4条记录; 例(2):查询student表中grade字段值从第五位到第八位的学生(从高到低) select * from student group desc limit 4,4 limit后面第一个参数表示偏移量位4,即从第五条开始查询,第二个参数表示一共返回4条记录,即从第五位到第8为学生 &gt;4.3.5 函数(列表) 函数名称 作用 ABS(x) 返回x的绝对值 SQRT(x) 返回x的非负2次方根 MOD(xy) 返回x被y除后的余数 CEILING(x) 返回x的绝对值 FLOOR(z) 返回x的绝对值 ROUND(x,y) 返回x的绝对值 TRUNCATE(x) 返回x的绝对值 SIGN(x)2 返回x的绝对值 4.4 为表和字段取别名 &gt; 4.4.1 为表取别名 在查询操作时,如果表名很长使用起来就不太方便,这时可以为表取一个别名,用这个别名来代替表的名称; 语法: select * from 表名 [as] 别名; as关键字用于指定表名的别名,它可以省略不写; 例如: 为student表起一个别名 s,并查询student表中gender字段值为'女'的记录 select * from student as s where s.gender='女'; student as s表示student表的别名为s s.gender 表示student表中的gender字段; &gt; 4.4.2 为字段取别名 为了让显示查询结果更加直观,可以为字段取一个别名 select 字段名 [as] 别名 [,字段名 [as] 别名,...] from 表名; 例如:查询student表中的所有记录的name和grade字段值,并为这两个字段名起别名stu_name和stu_genter; select * from name as stu_name, grader as stu_genter from student; 5.1 外键 &gt; 5.1.1 什么是外键 外键是指引用另一个表中的一列或多列,==被引用的列应该具有主键约束或唯一性约束.==外键用来建立和加强两个表数据之间的连接 引入外键后,外键列只能插入参照列存在的值,参照列被参照的值不能被删除,这就确保了数据的参照完整性 创建两个表,一个班级表(grade),一个学生表(student) create table grade( id int(4) not null primary key, name varchar(36) ); create table student( sid int(4) not null primary key, sname varchar(36), gid int(4) not null ); 学生表(student)中的gid 是学生所在的班级id,是引入了班级表(grade) 中的主键id,那么gid就可以作为表student的主键..被引用的表,即表grade是主表;引用外键的表,即表student是从表,两个表是主从关系. 表student用gid可以连接表grade中的信息 &gt;5.1.2 为表中添加外键约束 语法: alter table 表名 add constraint FK_ID foreign key(外键字段名) references 主表表名(主键字段名); 语句: alter table student add constraint FK_ID foreign key(gid) references grade(id); &gt;5.1.3 删除外键约束 在实际开发中,根据业务逻辑的需求,需要解除两个表的关联关系时, 就需要删除外键约束 语法: alter table 表名 drop foreign key 外键名; 接下来,将表中student表的外键约束删除 alter table student drop foreign key FK_ID; 5.2 操作关联表 &gt;5.2.1 关联关系 1.多对一 (外键定义在多端) 一个部门可以有多个员工，而一个员工不能属于多个部门。 在多对一的表关系中，应该将外键建在多的一方 2.多对多 (需定义中间表) 一个老师可以教多个学生，同时一个学生可以上多个老师的课程。 为了实现数据表多对多的关系，需要定义一张第三方中间表，该表保存两个关系表的外键。 3.一对一 (从表依赖主表) 一对一的对应关系中，需要分清主从关系，通常在从表中建立外键 &gt;5.2.2 添加数据 在开发中，最常见的关联关系就是多对一关系 为表student和表grade中添加外键约束来建立两个表的关联关系 alter table student add constraint FK_ID foreign key(gid) references grade (id); &gt;5.2.3 删除数据 由于grade表与student表之间具有关联关系 , 参照列被参照的值不能被删除的,再删除软件二班时需要删除软件二班的所有学生 delete from student where sname='王红'; delete from student where sname='李强'; delete * from grade where id=2; 5.3 连接查询 &gt; 5.3.1交叉连接 交叉连接返回的结果是被连接的两个表中所有数据行的笛卡尔积即行数的乘积 例如:department表中有4个部门,employee表中有4个员工,那么交叉连接的结果就有4X4=16条数据 语法: select *from 表1,表2; 或select * from 表1 cross join 表2; &gt; 5.3.2 内连接 内连接（INNER JOIN）又称简单连接或自然连接，内连接使用比较运算符对两个表中的数据进行比较，列出与连接条件匹配的数据行，组合成新的记录 简单连接或自然连接,返回的结果是两个表中一一对应的数据,只有满足条件的数据才显示 语法:select 查询字段 from 表1[inner] join 表2 on 表1.关系字段= 表2.关系字段 例如: 在department表和employee表之间使用内连接查询; select employee.name,department.dname from department inner join employee on department.did=employee.did; //只有department.did和employee.did相等的才输出 使用where条件语句来实现同样的功能; 例如:在department表和employee表之间使用where: select employee.name, department.dname from department,employee where department,did=employee.did; 注意:where子句的查询结果与使用inner join的查询结果是一致的,虽然结果相同,但inner join 是内连接语句,where是条件判断语句,在where语句后可以添加其他条件,而inner join语句不可以; 如果在一个连接查询中,涉及的两个表是同一个表,这种查询称为自连接查询,指的是相互连接的表在物理上为同一个表,但逻辑上分为两个表 查询部门为2的员工的姓名和年龄; select department.did,employee.name,employee.age from department join employee on department.did=employee.did where department.did=2; 或 select department.did,employee.name,employee.age from department,employee where department.did=employee.did and department.did=2; 查询姓名为王红所在的部门编号和部门名称 select employee.name,department.did,department.dname from department,employee where department.did=employee.did and employee.name='王红'; 自连接: 例如:在department表和employee表之间使用自连接查询王红所在的部门有哪些员工; select p1.* from employee p1 inner join employee p2 on p1.did=p2.did where p2.name='王红'; /*p1 p2为别名*/ 或select p1.* from employee p1,employee p2 where p1.did=p2.did and p2.name='王红';/*where方法*/ &gt; 5.3.3 外连接 外连接分为左连接和有连接 左连接的结果包括LEFT JOIN子句中指定的左表的所有记录，和所有满足连接条件的记录。如果左表的某条记录在右表中不存在，则在右表中显示为空 ; 右连接与左连接正好相反，返回右表中所有指定的记录和所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值 ; 做外链接:左表中的所有记录以及内连接的记录(放在前面的是左表) 右外连接:右表中的所有记录以及内连接的记录 语法: SELECT 所查字段 FROM 表1 LEFT|RIGHT [OUTER] JOIN 表2 ON 表1.关系字段 = 表2.关系字段 WHERE 条件 select * from 表1,表2 where表1.关系字段=表2.关系字段 and 其他条件 &gt;全外连接查询 在外连接的基础上,增加左边表有,右边表没有的记录,以及右边表有左边表没有的记录 语法: select * from 表1 full jion 表二 on 表一.关系字段=表二.关系字段; select * from dep full jion emp on dep.did=em.did; &gt;5.3.4 复合条件查询 5.4 子查询 &gt;5.4.1 带IN关键字的子查询 使用in关键字进行子查询时,内层查询语句仅返回一个数列值,这个数列值中的值将供外层查询语句进行比较操作 例如:查询存在年龄为20岁的员工的部门 select * from department where did in(select did from employee where age=20); 或 //子查询方法 select department.did,department.dname from department join employee on department.did=employee.did where employee.age=20; //内连接方法 或 select department.did,department.dname from department,employee where department.did=employee.did and employee.age=20; //where方法 &gt;5.4.2 带exists关键字的子查询 exists关键字后面的参数可以是任意一个子查询,这个子查询的作用相当于测试,他不产生任何数据,只返回true或false,当返回值为true时,外层查询才会执行 例如:查询employee表中是否存在年龄大于21岁的员工,如果存在,则查询department表中的所有记录 select * from department where exists(select did from employee where age&gt;21); &gt; 5.4.3 带any关键字的子查询 any关键字表示满足其中任意一个条件,它允许创建一个表达式对子查询的返回值列表进行比较 例如: select * from department where did&gt;any(select did from employee);//列出只要大于employee.did任意一个数 &gt;5.4.4 带all关键字的子查询 例如: select * from department where did&gt;all(select did from employee);/列出大于employee.did所有的数 &gt;5.4.5 带比较运算符的子查询 比较运算符 &gt; , &lt; , = , &gt;= , &lt;= , ! = 例如:使用比较运算符的子查询,查询赵四是哪个部门的员工 select * from department where did=(select did from employee where name =&quot;赵四&quot;); 6.1 事务管理 &gt; 6.1.1 事务的概念 所谓的事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，即事务中的语句要么都执行，要么都不执行 开启事务的语法: start transaction 上述语句用于开启事务,事务开启之后就可以执行SQL语句,SQL语句执行成功后,需使用相对应语句提交事务,语法如下: 提交事务的语法: commit 在操作一个事务时,如果发现当前事务中的操作是不合理的,此时只要还没有提交事务,就可以通过回滚来取消当前事务 事务回滚语句: rollback 6.2 存储过程的创建 &gt; 6.2.1 创建存储过程 存储过程就是一条或多条SQL语句的集合，当对数据库进行一系列复杂操作时，存储过程可以将这些复杂操作封装成一个代码块，以便重复使用，大大减少数据库开发人员的工作量 语法格式: CREATE PROCEDURE sp_name([proc_parameter]) [characteristics…]routine_body CREATE PROCEDURE：为用来创建存储过程的关键字。 sp_name: 为存储过程的名称。 proc_parameter: 为指定存储过程的参数列表。 characteristics : 用于指定存储过程的特性。 演示存储过程的创建 1.首先创建一个student表: mysql&gt; create table student( -&gt; id int(3) primary key auto_increment, -&gt; name varchar(20) not null, -&gt; grade float, -&gt; gender char(2) -&gt; ); 2.插入数据 mysql&gt; insert into student(name,grade,gender) -&gt; values('tom',60,'男'), -&gt; ('jack',70,'男'), -&gt; ('rose',90,'女'), -&gt; ('lucy',100,'女'); 3.创建一个查看student表的存储过程 创建一个存储过程proc,每次调用这个存储过程的时候都会执行select语句查看表的内容 mysql&gt; delimiter // --------&gt; 作用: 将MySQL的结束符设置为 // mysql&gt; create procedure proc() -&gt; begin -&gt; select * from student; -&gt; end // &gt; 6.2.2 变量的使用 在MySQL中, 变量可以在子程序中声明, 用于保存数据处理过程中的值, 这些变量的作用范围在BEGIN…END程序中 语法格式: DECLARE var_name[,varname]…date_type[DEFAULT value]; 例如: 定义一个名称为v1的变量，类型为INT类型，默认值为100,查询这个变量的值 mysql&gt; delimiter // mysql&gt; create procedure proc2() -&gt; begin -&gt; declare v1 int default 100; -&gt; select v1; -&gt; end // mysql&gt; delimiter ; mysql&gt; call proc2(); +------+ | v1 | +------+ | 100 | +------+ 例如: 声明三个变量,使用set为变量赋值 mysql&gt; delimiter // mysql&gt; create procedure proc2() -&gt; begin -&gt; declare v1,v2,v3 int; -&gt; set v1=10,v2=20; -&gt; set v3=v1+v2; -&gt; select v1,v2,v3; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc2(); +------+------+------+ | v1 | v2 | v3 | +------+------+------+ | 10 | 20 | 30 | +------+------+------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) 除了使用set语句为变量赋值外,MySQL中还可以通过select...into为一个或多个变量赋值, 该语句可以把选定的列直接储存到对应的位置的变量 语法格式如下: select col_name[...] into var_name [...] table_expr 上述语法格式中,col_name表示字段名称;var_name表示定义的变量名称,table_expr 表示查询条件表达式,包括表名称和where子句. 例如: select grade, gender into s_grade, s_gender from student where name= 'rose' ; 例:声明变量s_grade 和 s_gender,通过select ...into 语句 查询指定记录并为变量赋值 注意: 查询时如果不执行 select s_grade,s_gender; 则无返回结果 mysql&gt; delimiter // mysql&gt; create procedure proc4() -&gt; begin -&gt; declare s_grade float; -&gt; declare s_gender char(4); -&gt; select grade,gender into s_grade,s_gender from student where name='rose'; -&gt; select s_grade,s_gender; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; call proc4()// +---------+----------+ | s_grade | s_gender | +---------+----------+ | 90 | 女 | +---------+----------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 6.2.3 定义条件和处理程序 &gt; 1.定义条件 定义条件是指事先定义程序执行过程中遇到的问题。定义条件使用DECLARE语句，语法格式如下： DECLARE condition_name CONDITION FOR [condition_type]; // condition_type的两种形式： [condition_type]: SQLSTATE[VALUE] sqlstate_value|mysql_error_code condition_name：表示所定义的条件的名称； condition_type：表示条件的类型； sqlstate_value和mysql_error_code：表示MySQL的错误，sqlstate_value是长度为5的字符串类型错误代码，mysql_error_code为数值类型的错误代码。例如：ERROR1142（42000）中，sqlstate_value的值是42000，mysql_error_code的值是1142 例如 // 方法一: 使用sqlstate_value declare commad_not_allowed condition for sqlstate '42000'; // 方法二: 使用 mysql_error_code declare commad_not_allowed condition for 1064; &gt; 2. 定义处理程序 处理程序定义了在程序执行过程中遇到问题时应当采取的处理方式，并且保证存储过程在遇到警告或错误时能继续执行处理过程使用DECLARE语句定义，语法格式如下 : DECLARE handler_type HANDLER FOR condition_value[,…] sp_statement handler_type: CONTINUE|EXIT|UNDO condition_value: //包括5个字符的字符串错误值 ; |condition_name //表示declare condition 定义的错误条件名称 |SQLWARNING //匹配所有以01开头的sqlstate错误代码 |NOT FOUND //匹配所有以02开头的sqlstate错误代码 |SQLEXCEPTION //匹配所有没有被sqlwarning 或 not found捕获的sqlstate错误代码 |mysql_error_code //匹配数值类型错误代码 handler_type：为错误处理方式，参数取值 有3个：CONTINUE、EXIT和UNDO。CONTINUE：表示遇到错误不处理，继续执行； EXIT：遇到错误马上退出。 UNDO：表示遇到错误后撤回之前的操作，MySQL中暂时不支持这样的操作。sp_statement：参数为程序语句段，表示在遇到定义的错误时，需要执行的存储过程。 condition_value：表示错误类型 例如 : // 方法一:捕获sqlstate_value declare continue handler for sqlstate '42S02' set @info = 'no_such_table'; // 方法二:捕获mysql_error_code declare continue handler for 1146 set @info = 'no_such_table' // 方法三:先定义条件,然后调用 declare continue handler for no_such_table set @info='error'; // 方法四:使用sqlwarning declare exit handler for sqlwarning set @info='error'; // 方法五:使用not found declare exit handler for not found set @info='no_such_table'; // 方法六:使用sqlexception declare exit handler for sqlexception set @info='error'; &gt; 6.2.4 光标的使用 在编写存储过程时，查询语句可能会返回多条记录，如果数据量非常大，则需要使用光标来逐条读取查询结果集中的记录。光标是一种用于轻松处理多行数据的机制 &gt; 1. 光标的声明 想要使用光标处理结果集中的数据, 需要先声明光标 。光标必须声明在声明变量, 条件之后 语法: DECLARE cursor_name CURSOR FOR select_statement cursor_name表示光标的名称; select_statement表示select语句的内容, 返回一个用于创建光标的结果集 例如: 声明一个名为cursor_student的光标 DECLARE cursor_student CURSOR FOR select s_name,s_gender FROM student; &gt; 2. 光标的使用 首先要打开光标 语法: open cursor_name; select cursor_name into var_name[,var_name]... cursor_name 表示参数的名称; var_name 表示将光标中的select语句查询出来的信息存入该参数中, 需要注意的是, var_name必须在声明光标之前就定义好 例如: 使用名称为cursor_student的光标, 将查询出来的信息存入s_name和s_gender中 fetch cursor_student into s_name, s_gender; &gt; 3. 光标的关闭 使用完光标后要将光标关闭, 关闭光标的语法格式为 close cursor_name; &gt; 6.2.5 流程控制的使用 流程控制语句用于将多个sql语句划分或组合成符合业务逻辑的代码块 &gt;1. if语句 是指如果条件满足 mysql&gt; delimiter // mysql&gt; create procedure proc6() //定义一个存储过程; -&gt; begin //开始; -&gt; declare var int; //定义一个变量 var; -&gt; set var=10; //设置var的值,可不设置; -&gt; if var is null //if语句开始; -&gt; then select 'val is null'; -&gt; else select 'val is not null'; -&gt; end if; //if语句结束; -&gt; end // //结束; Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc6(); //查看 +-----------------+ | val is not null | +-----------------+ | val is not null | +-----------------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) &gt; 2. case 语句 mysql&gt; delimiter // mysql&gt; create procedure proc7() -&gt; begin -&gt; declare var int; -&gt; set var=1; -&gt; case var -&gt; when 1 then select 'val is 1'; -&gt; when 2 then select 'val is 2'; -&gt; else select 'val is not 1 or 2'; -&gt; end case; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc7(); +----------+ | val is 1 | +----------+ | val is 1 | +----------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 3.loop 语句 loop循环语句用来重复执行某些语句,并不会进行条件判断。 loop语句内的语句会一直重复执行直到跳出循环语句 基本语法如下 : [loop_label:]LOOP // loop_label 表示loop语句的标记名称,该参数可以省略 statement_list // statement_list 表示需要循环执行的语句 END LOOP [loop_label] &gt; 4. leave语句 当不满足循环条件时, 需要用leave语句退出循环 语法: leave label 例如: mysql&gt; create procedure proc8() -&gt; begin -&gt; declare id int default 0; -&gt; add_loop:LOOP -&gt; set id=id+1; -&gt; if id&gt;=10 then leave add_loop; -&gt; end if; -&gt; end LOOP add_loop; -&gt; select id; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; call proc8() // +------+ | id | +------+ | 10 | +------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) &gt; 5. iterate 语句 mysql&gt; delimiter // mysql&gt; create procedure proc9() -&gt; begin -&gt; declare p1 int default 0; //p1初始值为0; -&gt; my_loop:loop -&gt; set p1=p1+1; -&gt; if p1&lt;10 then iterate my_loop; //如果p1的值小于10是,重复执行p+1 -&gt; elesif p1&gt;20 then leave my_loop; //当p1的值大于或等于10并且小于20时 -&gt; end if; -&gt; select 'p1 is between 10 and 20'; //当p1的值大于或等于10并且小于20时,打印&quot;p1 is bet...&quot; -&gt; end loop my_loop; -&gt; end // &gt; 6. repeat 语句 作用: 创建一个带有条件判断的循环过程, 每次语句执行完毕后, 会对条件表达式进行判断, 如果表达式为真, 则循环结束; 否则重复执行循环中的语句 语法: [repeat_lable:] repeat //repeat_label为repeat语句的标注名称,该参数可选 statement_list utill expr_condition //reapeat语句内的语句或语句群被重复,直至expr_condition为真 end repeat [repeat_lable] 例如 mysql&gt; create procedure proc40() -&gt; begin -&gt; declare id int default 0; -&gt; repeat // -&gt; set id=id+1; -&gt; select id; //遍历 1-10; -&gt; until id&gt;=10 ---------&gt;&gt; 不带分号 -&gt; end repeat; // -&gt; end // Query OK, 0 rows affected (0.00 sec) &gt; 7. where 语句 作用: 创建一个带条件判断的循环过程, 与repeat 不同的是, where在语句执行时, 先对指定的表达式进行判断, 如果为真, 则执行循环内的语句, 否则退出循环 语法: [where_lable:] where expr_condition DO Statement_list end where [where_lable] mysql&gt; create procedure proc42() -&gt; begin -&gt; declare i int default 0; -&gt; while i&lt;10 do -&gt; set i=i+1; -&gt; select i; //遍历1-10; -&gt; end while; -&gt; end // Query OK, 0 rows affected (0.01 sec) 6.3 存储过程的使用 &gt; 6.3.1 调用存储过程 1.定义存储过程 mysql&gt; create procedure test2(in s_gender varchar(50),out num int ) -&gt; begin -&gt; select count(*) into num from student where gender=s_gender; -&gt; end // Query OK, 0 rows affected (0.00 sec) 2调用存储过程 mysql&gt; delimiter ; mysql&gt; call test2(&quot;女&quot;,@num); Query OK, 1 row affected (0.01 sec) 3.查看返回结果 mysql&gt; select @num; +------+ | @num | +------+ | 2 | +------+ 1 row in set (0.00 sec) &gt;6.3.2 查看存储过程 &gt; 1. show status 语句中查看存储过程的状态 mysql&gt; show procedure status like 'proc%' \\G *************************** 1. row *************************** Db: chapter06 Name: proc Type: PROCEDURE Definer: root@localhost Modified: 2020-11-25 08:32:11 Created: 2020-11-25 08:32:11 Security_type: DEFINER Comment: character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci *************************** 2. row *************************** Db: chapter06 Name: proc1 Type: PROCEDURE Definer: root@localhost Modified: 2020-11-25 09:15:20 Created: 2020-11-25 09:15:20 Security_type: DEFINER Comment: character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci &gt; 2. show create 语句中查看存储过程的状态&amp;创建语句 mysql&gt; show create procedure chapter06.proc1 \\G *************************** 1. row *************************** Procedure: proc1 sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `proc1`() begin select * from student; end character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: utf8_general_ci 1 row in set (0.00 sec) &gt; 3.从information_schema.Routine 表中查看存储过程的信息 mysql&gt; select * from information_schema.Routines -&gt; where routine_name='proc1' -&gt; and routine_type='procedure' \\G *************************** 1. row *************************** SPECIFIC_NAME: proc1 ROUTINE_CATALOG: def ROUTINE_SCHEMA: chapter06 ROUTINE_NAME: proc1 ROUTINE_TYPE: PROCEDURE DATA_TYPE: CHARACTER_MAXIMUM_LENGTH: NULL CHARACTER_OCTET_LENGTH: NULL NUMERIC_PRECISION: NULL NUMERIC_SCALE: NULL CHARACTER_SET_NAME: NULL COLLATION_NAME: NULL DTD_IDENTIFIER: NULL ROUTINE_BODY: SQL ROUTINE_DEFINITION: begin select * from student; end EXTERNAL_NAME: NULL EXTERNAL_LANGUAGE: NULL PARAMETER_STYLE: SQL IS_DETERMINISTIC: NO SQL_DATA_ACCESS: CONTAINS SQL SQL_PATH: NULL SECURITY_TYPE: DEFINER CREATED: 2020-11-25 09:15:20 LAST_ALTERED: 2020-11-25 09:15:20 SQL_MODE: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION ROUTINE_COMMENT: DEFINER: root@localhost CHARACTER_SET_CLIENT: gbk COLLATION_CONNECTION: gbk_chinese_ci DATABASE_COLLATION: utf8_general_ci 1 row in set (0.01 sec) 根据学号查询 mysql&gt; delimiter // mysql&gt; create procedure proc43(in myid int) -&gt; begin -&gt; select name from student where id=myid; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call proc43(1) ; +------+ | name | +------+ | tom | +------+ 根据输入的ID从学生表中查询该ID对应的姓名,并输出姓名 mysql&gt; delimiter // mysql&gt; create procedure test1(in myid int,out myname varchar(36)) -&gt; begin -&gt; select name into myname from student where id=myid; -&gt; end // Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ; mysql&gt; call test1(3,@myname) ; //调用存储过程 Query OK, 1 row affected (0.00 sec) mysql&gt; select @myname ; //查看返回结果 +---------+ | @myname | +---------+ | rose | +---------+ 1 row in set (0.00 sec) &gt; 6.3.3 修改存储过程 在MySQL中可以使用alter语句修改存储过程 语法格式如下: ALTER {PROCEDURE|FUNCTION} sp_name[characteristic…] sp_name：表示存储过程或函数的名称。characteristic：表示要修改存储过程的哪个部分 characteristic 的取值如下: 1.contains sql 表示子程序中包括sql语句, 但不包含读或写数据的语句; 2.no sql 表示子程序中不包括sql语句; 3.reads sql data 表示表示子程序中包括读数据的语句; 4.modifies sql data 表示子程序中包括写数据的语句; 5.sql security{definer|invoker} 指明谁有权限来执行; 6.definer 表示只有定义者自己才能执行; 7.invoker 表示调用者可以执行; 8.comment 'string' 表示注释信息; 注意: 目前此版本Mysql还不提供对已存在的存储过程代码的修改, 如果一定要修改存储过程代码, 必须先将存储过程删除之后, 再重新编写代码, 或创建一个新的存储过程 &gt; 6.3.4 删除存储过程 在MySQL中使用DROP语句修改存储过程，语法如下: DROP{ procedure|function }[if exists] sp_name if exists 表示如果程序不存在, 它可以避免发生错误, 产生一个警告 7.1 视图概述 ​ 视图是从基本表中导出来的表，是一种虚拟存在的表, 并且表的结构和数据都依赖于基本表 通过视图不仅可以看到放在基本表中的数据, 并且还可以像操作基本表一样, 对视图中存放的数据进行查询 删除,修改 .与直接操作表相比视图具有以下优点: 1.简化查询语句 日常开发中我们可以将经常使用的查询定义为视图，从而使用户避免大量重复的操作。 2安全性 通过视图用户只能查询和修改他们所能见到的数据，数据库中的其他数据则既看不到也取不到。 3逻辑数据独立性 视图可以帮助用户屏蔽真实表结构变化带来的影响。 7.2 视图管理 &gt; 7.2.1 创建视图的语法格式: create [or replace] [algorithm={undefined | merge | temptable] view view_name [(column_list)] as select_statement [where [cascaded|local] check option] CREATE：表示创建视图的关键字。 OR REPLACE：表示该语句能够替换已有视图。 ALGORITHM：可选，表示视图选择的算法。 UNDEFINED：表示MySQL将自动选择所要使用的算法。 MERGE：使得视图定义的某一部分取代语句的对应部分。 TEMPTABLE：表示将视图的结果存入临时表，然后使用临时表执行语句。 view_name：表示要创建的视图名称。 column_list：可选，表示属性清单。 AS：表示指定视图要执行的操作。 SELECT_statement：表示从某个表或视图中查出满足条件的记录，并导入视图中。 WITH CHECK OPTION：可选，表示创建视图时要保证在该视图的权限范围之内。 CASCADED：需要满足跟该视图有关的所有相关视图和表的条件，该参数为默认值。 LOCAL：可选。表示创建视图时，只要满足该视图本身定义的条件即可。 &gt;7.2.2 在单标上创建视图 在student表上创建view_stu视图和view_stu2视图(自定义字段名) 1.创建数据库,表,插入数据 mysql&gt; create database chapter07; Query OK, 1 row affected (0.04 sec) mysql&gt; use chapter07 Database changed mysql&gt; create table student( -&gt; s_id int(3), -&gt; name varchar(20), -&gt; math float, -&gt; chinese float -&gt; ); Query OK, 0 rows affected (0.05 sec) mysql&gt; insert into student(s_id,name,math,chinese) values -&gt; (1,'Tom',80,78), -&gt; (2,'Jack',70,80), -&gt; (3,'Lucy',97,95); Query OK, 3 rows affected (0.05 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from student; +------+------+------+---------+ | s_id | name | math | chinese | +------+------+------+---------+ | 1 | Tom | 80 | 78 | | 2 | Jack | 70 | 80 | | 3 | Lucy | 97 | 95 | +------+------+------+---------+ 3 rows in set (0.00 sec) 2.创建视图并查询 mysql&gt; create view view_stu as select math,chinese,math+chinese from student; mysql&gt; select * from view_stu; +------+---------+--------------+ | math | chinese | math+chinese | +------+---------+--------------+ | 80 | 78 | 158 | | 70 | 80 | 150 | | 97 | 95 | 192 | +------+---------+--------------+ 3 rows in set (0.00 sec) mysql&gt; create view view_stu2(math,chinese,sum) as select math,chinese,math+chinese from student; Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from view_stu2; +------+---------+------+ | math | chinese | sum | +------+---------+------+ | 80 | 78 | 158 | | 70 | 80 | 150 | | 97 | 95 | 192 | +------+---------+------+ 3 rows in set (0.00 sec) &gt; 7.2.3 在多表上创建视图 在student表和stu_info表中创建stu_class视图, 查询s_id号,姓名和班级 1.创建数据库,表,插入数据 mysql&gt; create table stu_info( -&gt; s_id int(3), -&gt; class varchar(50), -&gt; addr varchar(100) -&gt; ); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into stu_info(s_id,class,addr) values -&gt; (1,'erban','anhui'), -&gt; (2,'sanban','chongqing'), -&gt; (3,'yiban','shandong'); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from stu_info; +------+--------+-----------+ | s_id | class | addr | +------+--------+-----------+ | 1 | erban | anhui | | 2 | sanban | chongqing | | 3 | yiban | shandong | +------+--------+-----------+ 3 rows in set (0.00 sec) 2.创建视图并查询 mysql&gt; create view stu_class(id,name,class) as select student.s_id,student.name,stu_info.class from student,stu_info where student.s_id=stu_info.s_id; Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from stu_class; +------+------+--------+ | id | name | class | +------+------+--------+ | 1 | Tom | erban | | 2 | Jack | sanban | | 3 | Lucy | yiban | +------+------+--------+ 3 rows in set (0.00 sec) &gt; 7.2.4 查看视图 &gt; 1. 使用describe 语句查看视图 作用: 使用DESCRIBE语句可以查看视图的字段信息 语法: DESCRIBE 视图名; 或 DESC 视图名; 例如: desc[describe] stu_class; &gt; 2. 使用 show table status 作用: 可以查看视图的基本信息 语法: SHOW TABLE STATUS LIKE '视图名'; ----&gt; 注意like 引号 例如: show table status like 'stu_class' \\G; &gt; 3. 使用 show create view 作用: 不仅可以查看创建视图时的定义语句，还可以查看视图的字符编码 语法: SHOW CREATE VIEW 视图名; 例如: show create view stu_class \\G; &gt; 7.2.5 修改视图 &gt; 1. 使用 create or replace view 语句修改视图; 语法 : create or replace view 视图名 as select 表中字段 from 表名 create or replace view view_stu as select * from student; &gt; 2. 使用 alter 语句修改视图; 语法 : alter view 视图名 as select 表中字段 from 表名 alter view view_stu as select chinese from student; &gt; 7.2.6 更新视图 1. 使用update 语句更新视图 update view_stu set chinese=100; 2. 使用insert 语句更新视图 insert into student values(4,'Lily',100,100); 3. 使用delete语句更新视图 delete from view_stu2 where math=10; 7.2.7 删除视图 视图不在需要时,可以将其删除,删除视图只会删除视图的定义,不会删除数据. 删除一个或多个视图可以使用dorp view语句, 删除视图的基本语法格式如下所示: drop view [if exists] view_name [,view_name1] ... [restrict|cascade] view_name 是指要删除的视图的名称,视图名称可以添加多个,各个名称用逗号隔开,删除视图必须有root权限 例如: 删除view_stu2视图 drop view if exists view_stu2; 8.1 数据备份与还原 8.1.1 数据的备份 通过MySQL的mysqldump命令实现数据的备份 1. 备份单个数据库 mysqldump 命令备份数据库的语法格式如下 : mysqldump -u username -p password dbname [tbname] [tbname2...] &gt; filename.sql 上述语法格式中, -u后面的参数username 表示用户名, -p 后面的参数 password表示登录密码, dbname 表示需要备份的数据库的名称, tbname表示数据库中的表名, 可以指定一个表或多个表, 多个表之间用空格隔开, 如果不指定则备份整个数据库, filename.sql 表示备份文件的名称, 文件名前可以加上绝对路径 注意: 在使用mysqldump命令备份数据库时, 直接在dos命令行窗口中执行该命令即可, 不需要登录到mysql数据库 例如: 例如: 创建一个名称为chapter08的数据库, 并在数据库中创建表student, 插入相应数据 mysql&gt; create database chapter08 mysql&gt; use chapter08 Database changed mysql&gt; create table student( -&gt; id int primary key auto_increment, -&gt; name varchar(20), -&gt; age int -&gt; ); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into student(name,age) values -&gt; ('Tom',20), -&gt; ('Jack',16), -&gt; ('Lucy',18); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from student; +----+------+------+ | id | name | age | +----+------+------+ | 1 | Tom | 20 | | 2 | Jack | 16 | | 3 | Lucy | 18 | +----+------+------+ 3 rows in set (0.00 sec) 首先在C盘创建一个名为backupdb的 文件夹用来存备份好的文件夹, 然后重新开启一个dos命令行窗口( 不需要登录到MySQL数据库), 使用mysqldump命令登录备份chapter08 语法: C:\\Users\\ASUS&gt;mysqldump -u root -p chapter08 &gt; C:/backupdb/chapter08.sql Enter password: **** 查看备份: -- MySQL dump 10.13 Distrib 5.5.28, for Win32 (x86) -- -- Host: localhost Database: chapter08 -- ------------------------------------------------------ -- Server version 5.5.28 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!40101 SET NAMES utf8 */; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */; /*!40103 SET TIME_ZONE='+00:00' */; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; -- -- Table structure for table `student` -- DROP TABLE IF EXISTS `student`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!40101 SET character_set_client = utf8 */; CREATE TABLE `student` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; /*!40101 SET character_set_client = @saved_cs_client */; -- -- Dumping data for table `student` -- LOCK TABLES `student` WRITE; /*!40000 ALTER TABLE `student` DISABLE KEYS */; INSERT INTO `student` VALUES (1,'Tom',20),(2,'Jack',16),(3,'Lucy',18); /*!40000 ALTER TABLE `student` ENABLE KEYS */; UNLOCK TABLES; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; -- Dump completed on 2020-12-16 8:30:50 2. 备份多个数据库 mysqldump –u username –p password -–database dbname1 [dbname2 dbname3…] &gt;filename.sql 3. 备份所以数据库 mysqldump –uusername –ppassword -–all-databases&gt;filename.sql 8.1.2 数据的还原 语法: mysql –uusername –ppassword [dbname] &lt;filename.sql 1. 删除数据库 mysql&gt; drop database chapter08; 2. 创建数据库 mysql&gt; create database chapter08; Query OK, 1 row affected (0.01 sec) 3. 还原数据库 C:\\Users\\ASUS&gt;mysql -u root -p chapter08 &lt; C:/backupdb/chapter08-1.sql Enter password: **** 4. 查看数据 mysql&gt; use chapter08 Database changed mysql&gt; select * from student; +----+------+------+ | id | name | age | +----+------+------+ | 1 | Tom | 20 | | 2 | Jack | 16 | | 3 | Lucy | 18 | +----+------+------+ 3 rows in set (0.00 sec) 8.2 用户管理 8.2.1 user表 在安装数据库的时候会自动安装一个名为mysql的数据库, 该数据库中的表都是权限表, 如user, db, host ,table_priv 其中user表是最重要的一个权限表, 它记录了允许链接到服务器的账号信息以及一些全局级的权限信息, 通过操作表就可以对这些信息进行修改 mysql&gt; use mysql mysql&gt; desc user; +------------------------+-----------------------------------+------+-----+---------+-------+ | Field 字段名 | Type 数据类型 | Null | Key | Default | Extra | +------------------------+-----------------------------------+------+-----+---------+-------+ | Host | char(60) | NO | PRI | | | | User | char(16) | NO | PRI | | | | Password | char(41) | NO | | | | | Select_priv | enum('N','Y') | NO | | N | | | Insert_priv | enum('N','Y') | NO | | N | | | Update_priv | enum('N','Y') | NO | | N | | | Delete_priv | enum('N','Y') | NO | | N | | | Create_priv | enum('N','Y') | NO | | N | | | Drop_priv | enum('N','Y') | NO | | N | | | Reload_priv | enum('N','Y') | NO | | N | | | Shutdown_priv | enum('N','Y') | NO | | N | | | Process_priv | enum('N','Y') | NO | | N | | | File_priv | enum('N','Y') | NO | | N | | | Grant_priv | enum('N','Y') | NO | | N | | | References_priv | enum('N','Y') | NO | | N | | | Index_priv | enum('N','Y') | NO | | N | | | Alter_priv | enum('N','Y') | NO | | N | | | Show_db_priv | enum('N','Y') | NO | | N | | | Super_priv | enum('N','Y') | NO | | N | | | Create_tmp_table_priv | enum('N','Y') | NO | | N | | | Lock_tables_priv | enum('N','Y') | NO | | N | | | Execute_priv | enum('N','Y') | NO | | N | | | Repl_slave_priv | enum('N','Y') | NO | | N | | | Repl_client_priv | enum('N','Y') | NO | | N | | | Create_view_priv | enum('N','Y') | NO | | N | | | Show_view_priv | enum('N','Y') | NO | | N | | | Create_routine_priv | enum('N','Y') | NO | | N | | | Alter_routine_priv | enum('N','Y') | NO | | N | | | Create_user_priv | enum('N','Y') | NO | | N | | | Event_priv | enum('N','Y') | NO | | N | | | Trigger_priv | enum('N','Y') | NO | | N | | | Create_tablespace_priv | enum('N','Y') | NO | | N | | | ssl_type | enum('','ANY','X509','SPECIFIED') | NO | | | | | ssl_cipher | blob | NO | | NULL | | | x509_issuer | blob | NO | | NULL | | | x509_subject | blob | NO | | NULL | | | max_questions | int(11) unsigned | NO | | 0 | | | max_updates | int(11) unsigned | NO | | 0 | | | max_connections | int(11) unsigned | NO | | 0 | | | max_user_connections | int(11) unsigned | NO | | 0 | | | plugin | char(64) | YES | | | | | authentication_string | text | YES | | NULL | | +------------------------+-----------------------------------+------+-----+---------+------- 1. 用户列 用户列包括Host、User、Password,分别代表主机名、用户名和密码 其中Host和User列为user表的联合主键 当修改密码时，只需要修改,user表中Password字段的值即可 2. 权限列 user表的权限列包括Select_priv、Insert_priv、Update_priv等以priv结尾的字段，这些字段决定了用户的权限，其中包括查询权限、修改权限、关闭服务等权限。 3.安全列 user表的安全列用于管理用户的安全信息，其中包括6个字段，具体如下： ssl_type和ssl_cipher：用于加密 x509_issuer和x509_subject标准：可以用来标识用户 plugin和authentication_string：用于存储与授权相关的插件 4. 资源控制列 资源控制列是用于限制用户使用的资源，包括4个字段，具体如下： max_questions：每小时允许用户执行查询操作的次数 max_updates：每小时允许用户执行更新操作的次数 max_connections：每小时允许用户建立连接的次数 max_user_connections：允许单个用户同时建立连接的次数 8.2.2 创建普通用户 1. 使用 grant 语句创建用户 GRANT privileges ON database.table TO 'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname [IDENTIFIED BY [PASSWORD]'password']] … privileges 参数表示该用户具有的权限信息, database.table 表示新用户的权限范围表, 可以在指定的数据库, 表上使用自己的权限, username参数是新用户的名称, hostname参数是主机名, password参数是新用户的密码 例如: 使用grant 语句创建一个新用户, 用户名是user1, 密码是 123, 并授予该用户对chapter08.student 表具有查询权限 grant select on chapter08.student to 'user1'@'localhost' identified by '123'; mysql&gt; select host,user,password from user; +-----------+-------+-------------------------------------------+ | host | user | password | +-----------+-------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | localhost | user1 | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | +-----------+-------+-------------------------------------------+ 3 rows in set (0.00 sec) 2. 使用 create user 语句创建用户 CREATE USER 'username'@'hostname'[IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname'[IDENTIFIED BY [PASSWORD]'password']]… username参数是新用户的名称, hostname参数是主机名,identified by关键字用于设置用户的密码, password 表示用户的密码, [PASSWORD] 关键字表示使用哈希值设置的密码, 该参数是可选的, 如果密码是一个普通的字符串, 就不需要使用PASSWORD 关键字 例如: 使用create user语句创建一个新用户, 用户名为user2, 密码是123, create user语法如下: create user 'user2'@'localhost' identified by '123'; 3. 使用 insert 语句创建用户 INSERT INTO mysql.user(Host,User,Password,ssl_cipher、x509_issuer、x509_subject) VALUES('hostname','username',PASSWORD('password'),'','',''); 上述语法格式中, mysql.user表示操作的表, Host,User,Password,ssl_cipher、x509_issuer、x509_subject 为相应字段 PASSWORD( ) 是一个加密函数, 用于给密码加密 注意: 使用insert添加用户时, 通常只需要添加host, user和password这三个字段即可, 其他字段取默认值,但由于 Host,User,Password,ssl_cipher、x509_issuer、x509_subject 字段是没有默认值的, 因此insert语句创建用户时, 还需要为这几个字段设置初始值 例如: 使用insert 语句直接在mysql.user表中创建一个新用户, 用户名为user3, 密码为123 ,insert语句如下: insert into mysql.user(Host,User,Password,scl_cipher,x509_issuer,x509_subject) values('localhost','user3',password('123'),'',''); 注意: insert语句没有刷新权限表的功能, 因此,user3用户暂时不能使用,为了让当前用户生效, 还需要手动刷新当前的权限表或重新启动mysql服务, 刷新权限表的语句如下: flush privileges; 8.2.3 删除普通用户 1. 使用drop user 语句删除用户 drop user语句与drop database 语句有些相似, 如果删除某个用户, 只需在 drop user 后面指定要删除的用户信息即可 语法: drop user 'username'@'hostname'[,'username'@'hostname']; username 表示要删除的用户, hostname表示主机名, drop user语句可以同时删除一个或多个用户, 多个用户之间可以使用逗号隔开 注意: 使用drop user语句来删除用户时, 必须拥有drop user 权限 使用drop user语句删除用户 user1 drop user 'user'@'localhost'; 2. 使用 delete 语句删除用户 delete语句不仅可以删除普通表中的数据, 还可以删除 user表中的数据, 使用该语句删除 user表中的数据时, 只需要指定表名为mysql.user, 以及要删除的用户信息即可, 同样的, 在使用delete语句时必须拥有对mysql.user表的delete权限 语法格式如下: delete from mysql.user where host='hostname' and user='username'; 上述语法格式中, mysql.user 参数指定要操作的表, where 指定条件语句, host和user 都是mysql.user 表的字段, 这两个字段可以确定唯一的一条记录 例如: 使用delete语句删除用户 user2 delete from mysql.user where host='localhost' and user='user2'; 注意: 由于直接对user表进行操作, 执行完命令后需要使用'flush privileges' 语句重新加载用户权限 8.2.4 修改用户密码 1. 修改 root用户密码 一. 通过mysqladmin命令修改root用户的密码 mysqladmin命令通常用于执行一些管理性工作 语法格式如下: mysqladmin -u username [-h hostname] -p password new_password; username为要修改的用户名, 这里指的是root用户, 参数 -h 用于指定对应的主机, 可以省略不写, 默认为 localhost -p 后面的password为关键字, 而不是修改后的密码, new_password 为新设置的密码 注意: 在使用mysqladmin命令修改root用户密码时, 需要在 C: \\document and setting\\administrator&gt;目录下进行修改 例如: 在命令行窗口中使用mysqladmin命令, 将root用户的密码修改为mypwd1,sql语句如下: mysqladmin -u root -p password mypwd1 二. 通过update语句修改root用户的密码 由于所以的用户信息都存放在mysql.user表中, 因此,只有root用户登录到MySQL服务器, 使用update语句就可以直接修改自己的密码 语法格式如下 update mysql.user set password=password('mypwd2') where user='root' and host='localhost'; 上述语法执行成功后, 还需要使用 flush privileges 重新加载权限表, 然后就可以使用新密码登录 mysql数据库 结果如下 : 三. 使用set 语句修改root用户的密码 root用户登录到mysql数据库后, 还可以通过set语句修改root用户的密码 set语句修改密码的语法格式如下: set password=password('new_password'); 注意: 由于set语句没有对密码加密的功能, 因此, 新密码必须使用password() 函数加密, 并且新密码需要使用引号括起 例如: root用户登录到mysql数据库, 使用set 语句将root用户的密码修改为mypwd3, set语句如下: set password=password('mypwd3'); 2. root 用户修改普通用户的密码 1.使用grant语句修改普通用户密码 grant语句的作用比较多, 不仅可以创建用户授权, 还可以修改用户的密码, 通常情况下, 为了不影响当前账户的权限, 可以使用grant usage语句修改指定的账户的密码 grant语句修改密码语法格式如下: grant usage on * . * to 'username'@'localhost' identified by [password] 'new_password'; 2.使用update语句修改普通用户的密码 root用户具有操作数据库的所有权限, 因此, 它不仅可以使用update语句修改自己的密码, 还可以使用update语句修改普通用户的密码 update的语法格式为与root修改用户密码的语法格式相同 update mysql.user set password=password('new_password') where user='username' and host='hostname'; 注意: 通过上述语句修改完普通用户的密码后, 还需要使用flush privileges语句重新加载权限表 3.使用set语句修改普通用户的密码 set 不仅可以修改root用户的密码, 而且还可以修改普通用户密码, 在修改普通用户密码时, 还需要增加一个for子句, 指定要修改哪一个用户即可 set语句修改密码的语法格式如下 set password for 'username'@'hostname'=password('new_password'); 3. 普通用户修改密码 普通用户也可以修改自己的密码, 这样普通用户就不需要每次修改密码时都通知管理员, 普通用户登录到MySQL服务器后, 可以通过set语句来设置自己的密码 set语句的基本格式如下: set password=password('new_password'); set语句修改普通用户密码时, 和修改root用户是一样的, 都需要使用password() 函数进行加密 8.3 权限管理 8.3.1 MySQL的权限 Mysql中的权限信息被储存在mysql 数据库的 user,db,host,table_priv,column_priv和procs_priv表中, 当MySQL启动时会自动加载这些权限信息, 并将这些权限信息读取到内存中 权限解释: 1. create和drop的权限, 可以创建数据库,表,索引,或者删除已有的数据库, 表, 索引 2. insert, delete,update,select 权限,可以对数据库中的表进行增删改查操作 3. index权限,可以创建或删除索引, 适用于所以的表 4. alter权限.可以用于修改表的结构或重命名表 5. grant权限, 允许为其他用户授权, 可用于数据库和表 6. file权限, 被赋予该权限的用户能读写MySQL服务器上的任何文件 8.3.2 授予权限 我们之所以可以对数据进行增删改查的操作，是因为数据库中的用户拥有不同的权限，合理的授权可以保证数据库的安全 MySQL中的GRANT语句可以为用户授权，语法格式如下: GRANT privileges [(columns)][,privileges[(columns)]] ON database.table TO 'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password'] [,'username'@'hostname' [IDENTIFIED BY [PASSWORD]'password']] … [WITH with_option [with_option]…] privileges：表示权限类型。 columns：参数表示权限作用于某一列，该参数可以省略不写，此时权限作用于整个表，username：表示用户名。 hostname表示主机名。 IDENTIFIED BY：参数为用户设置密码。 PASSWORD参数为关键字. password为用户的新密码。 WITH关键字后面可以带有多个参数with_option，这个参数有五个取值 具体如下: GRANT OPTION：将自己的权限授予其他用户MAX_QUERIES_PER_HOUR count：设置每小时最多可以执行多少次（count）查询。 MAX_UPDATES_PER_HOUR count：设置每小时最多可以执行多少次更新。 MAX_CONNECTIONS_PER_HOUR count：设置每小时最大的连接数量。 MAX_USER_CONNECTIONS：设置每个用户最多可以同时建立连接的数量。 8.3.3 查看权限 虽然使用SELECT语句可以查询user表中的权限信息，但是该语句需要指定用户和查询的权限，比较麻烦，MySQL还提供了一个查看权限的简单语句-SHOW GRANTS语句 SHOW GRANTS的语法格式如下: SHOW GRANTS FOR 'username'@'hostname'; 语法格式相对简单, 只需要指定查询的用户名和主机名即可 例1: 使用show grants语句查询root用户的权限信息 show grants for 'root'@'hostname'; 例2: 使用show grants语句查询user4 用户的权限信息 show grants for 'user4'@'hostname'; 8.3.4 收回权限 为了保证数据库的安全性，需要将用户不必要的权限收回，收回用户权限使用REVOKE语句 收回用户指定权限, 语法格式如下所示 : REVOKE privileges [columns][,privileges[(columns)]] ON database.table FROM 'username'@'hostname'[,'username'@'hostname'] … revoke语法格式中的参数与grant语句中的参数意思相同, privileges参数表示收回的权限,columns表示权限作用于哪列上, 如果不指定该参数表示作用于整个表 使用revoke语句收回user4用户的insert权限, revoke语句如下: revoke insert on * . * from 'user'@'localhost'; 如果权限比较多可以使用收回所以权限的功能 收回用户全部权限, 语法格式如下所示 : REVOKE ALL PRIVILEGES,GRANT OPTION FROM 'username'@'hostname' [,'username'@'hostname'] … 使用revoke语句收回user4用户的insert权限, revoke语句如下: revoke all privileges,grant option from 'user4'@'localhost'; ","tags":[{"index":-1,"name":"MySQL","slug":"mfzycuj_f","used":true,"link":"https://aoianz.github.io/tag/mfzycuj_f/"}],"title":"朝花夕拾 Mysql","feature":"https://aoianz.github.io/post-images/mysql.jpg","link":"https://aoianz.github.io/post/mysql/","stats":{"text":"80 min read","time":4757000,"words":18778,"minutes":80},"date":"2021-01-11 22:18:18","dateFormat":"2021-01-11"}]}